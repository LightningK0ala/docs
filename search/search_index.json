{
    "docs": [
        {
            "location": "/", 
            "text": "Colyseus is a Authoritative Multiplayer Game Server for Node.js. It allows you to focus on your gameplay instead of bothering about networking.\n\n\nThe mission of this framework is to be the easiest solution for creating your\nown multiplayer games in JavaScript. \n\n\nThis framework is fairly new and is being evolved constantly. You're encouraged to take a look on \nsome games being developed with it\n and make your own!\n\n\nWhat Colyseus provides to you:\n\n\n\n\nWebSocket-based communication\n\n\nSimple API in the server-side and client-side.\n\n\nAutomatic state synchronization between server and client.\n\n\nMatchmaking clients into game sessions\n\n\nScale on many processes on a single machine.\n\n\n\n\nWhat Colyseus won't provide:\n\n\n\n\nGame Engine: Colyseus is agnostic of the engine you're using. Need Physics? Add your own logic / package.\n\n\nDatabase: It's up to configure and select which database you'd like to use.\n\n\n\n\nWhat people are saying about it?\n\n\n\n\n@bmovement\n\n\n\"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\"\n\n\n\n\n\n\n@sagestudios\n\n\nLoved the framework. Exactly what we are looking for in terms of features.\n\n\n\n\nExternal links\n\n\n\n\n\ud83c\udf10 \n Website\n\n\n\ud83d\udcac \n Forum\n\n\n\ud83d\udcb0 \n Support the project", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-colyseus-provides-to-you", 
            "text": "WebSocket-based communication  Simple API in the server-side and client-side.  Automatic state synchronization between server and client.  Matchmaking clients into game sessions  Scale on many processes on a single machine.", 
            "title": "What Colyseus provides to you:"
        }, 
        {
            "location": "/#what-colyseus-wont-provide", 
            "text": "Game Engine: Colyseus is agnostic of the engine you're using. Need Physics? Add your own logic / package.  Database: It's up to configure and select which database you'd like to use.", 
            "title": "What Colyseus won't provide:"
        }, 
        {
            "location": "/#what-people-are-saying-about-it", 
            "text": "@bmovement  \"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\"    @sagestudios  Loved the framework. Exactly what we are looking for in terms of features.", 
            "title": "What people are saying about it?"
        }, 
        {
            "location": "/#external-links", 
            "text": "\ud83c\udf10   Website  \ud83d\udcac   Forum  \ud83d\udcb0   Support the project", 
            "title": "External links"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started\n\n\nEnvironment\n\n\nColyseus requires \nNode.js\n v6.0.0 or higher.\n\n\nSee some examples in action by cloning the \nexamples\n project and running it locally.\n\n\ngit clone https://github.com/gamestdio/colyseus-examples.git\ncd colyseus-examples\nnpm install\n\n\n\n\n\nTo run the http + websocket server, run \nnpm start\n.\n\n\nThe Mindset\n\n\nThe authoritative game server mindset is quite simple. The Server validates the user actions, and clients are dumb visual representations of the current game state.\n\n\nThe server should take care of all data involved in your game, such as positioning, speeds, collisions, etc.\n\n\nMaking multiplayer games is usually tricky because your gameplay must take the multiple delays into account - the other clients sending data to the server, and the server sending data back to all clients. It's the art of faking something that has already happened is actually happening as the current player sees and plays the game.\n\n\nHere's how the \"multiplayer game loop\" looks like on Colyseus:\n\n\n\n\nClient sends a message to the server, requesting to change its state.\n\n\nThe input must be validated by your room handler.\n\n\nThe game state is updated.\n\n\nAll clients receive the latest version of the game state.\n\n\nThe visual representation of the game state is updated.\n\n\n\n\nDiagram\n\n\n              room.send({ action: \nleft\n })\n\n                           |\n      +------------+       |       +-----------------------------------+\n+-----+ Client #1  +-------|       |  Room handler #1                  |\n|     +------------+       |       |                                   |\n|     +------------+       |       |  onMessage (client, data) {       |\n|-----+ Client #2  |       --------+    if (data.action === \nleft\n) {  |\n|     +------------+               |      // update the room state     |\n|     +------------+               |    }                              |\n|-----+ Client #3  |               |  }                                |\n|     +------------+               +-----------------------------------+\n|                                                    |\n|        patch state broadcast (binary diff)         |\n|----------------------------------------------------+\n\n\n\n\n\nRecommended NodeJS packages for games\n\n\nThese modules can be useful while developing games on both NodeJS and the Browser.\n\n\n\n\n@gamestdio/mathf\n - Mathematical functions, borrowed from Unity3D's API\n\n\n@gamestdio/timer\n - Reliable timing events\n\n\n@gamestdio/keycode\n - Constants for keyboard key codes (\nevent.which\n)\n\n\n\n\nThese modules can be used only in the browser:\n\n\n\n\n@gamestdio/pixi-engine", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#environment", 
            "text": "Colyseus requires  Node.js  v6.0.0 or higher.  See some examples in action by cloning the  examples  project and running it locally.  git clone https://github.com/gamestdio/colyseus-examples.git\ncd colyseus-examples\nnpm install  To run the http + websocket server, run  npm start .", 
            "title": "Environment"
        }, 
        {
            "location": "/getting-started/#the-mindset", 
            "text": "The authoritative game server mindset is quite simple. The Server validates the user actions, and clients are dumb visual representations of the current game state.  The server should take care of all data involved in your game, such as positioning, speeds, collisions, etc.  Making multiplayer games is usually tricky because your gameplay must take the multiple delays into account - the other clients sending data to the server, and the server sending data back to all clients. It's the art of faking something that has already happened is actually happening as the current player sees and plays the game.  Here's how the \"multiplayer game loop\" looks like on Colyseus:   Client sends a message to the server, requesting to change its state.  The input must be validated by your room handler.  The game state is updated.  All clients receive the latest version of the game state.  The visual representation of the game state is updated.", 
            "title": "The Mindset"
        }, 
        {
            "location": "/getting-started/#diagram", 
            "text": "room.send({ action:  left  })\n\n                           |\n      +------------+       |       +-----------------------------------+\n+-----+ Client #1  +-------|       |  Room handler #1                  |\n|     +------------+       |       |                                   |\n|     +------------+       |       |  onMessage (client, data) {       |\n|-----+ Client #2  |       --------+    if (data.action ===  left ) {  |\n|     +------------+               |      // update the room state     |\n|     +------------+               |    }                              |\n|-----+ Client #3  |               |  }                                |\n|     +------------+               +-----------------------------------+\n|                                                    |\n|        patch state broadcast (binary diff)         |\n|----------------------------------------------------+", 
            "title": "Diagram"
        }, 
        {
            "location": "/getting-started/#recommended-nodejs-packages-for-games", 
            "text": "These modules can be useful while developing games on both NodeJS and the Browser.   @gamestdio/mathf  - Mathematical functions, borrowed from Unity3D's API  @gamestdio/timer  - Reliable timing events  @gamestdio/keycode  - Constants for keyboard key codes ( event.which )   These modules can be used only in the browser:   @gamestdio/pixi-engine", 
            "title": "Recommended NodeJS packages for games"
        }, 
        {
            "location": "/concept-state-synchronization/", 
            "text": "State synchronization\n\n\n\n\nColyseus uses \nMessagePack\n to encode the room state in a binary format.\n\n\nUpon first connection, the client receives the latest full binary room state.\n\n\nThe binary patch is evaluated through \nFossil's Delta algorithm\n at every \npatch interval\n.\n\n\nThe patched room state is sent to all connected clients.", 
            "title": "State synchronization"
        }, 
        {
            "location": "/concept-state-synchronization/#state-synchronization", 
            "text": "Colyseus uses  MessagePack  to encode the room state in a binary format.  Upon first connection, the client receives the latest full binary room state.  The binary patch is evaluated through  Fossil's Delta algorithm  at every  patch interval .  The patched room state is sent to all connected clients.", 
            "title": "State synchronization"
        }, 
        {
            "location": "/concept-matchmaking/", 
            "text": "To allow matchmaking on your Colyseus server, you'll need to implement a room handler, and register it in your server.\n\n\nSee:\n\n\n\n\nRoom\n\n\nServer#register()\n\n\n\n\nThe matchmaking cycle\n\n\n1.\n Client asks to connect into a specific room:\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \n// client-side\n\n\nlet\n \nroom\n \n=\n \nclient\n.\njoin\n(\nbattle\n);\n\n\n\n\n        \n\n    \n        \n\n            \n// client-side\n\n\nRoom\n \nroom\n \n=\n \nclient\n.\nJoin\n(\nbattle\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n2.\n Server will loop through all spawned room instances named \n\"battle\"\n and call \nrequestJoin\n method against that instance.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nExample 1\n\n        \n\n    \n        \n\n            \nExample 2\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \n// server-side\n\n\nrequestJoin\n \n(\noptions\n: \nany\n)\n \n{\n\n    \n// Prevent the client from joining the same room from another browser tab\n\n    \nreturn\n \nthis\n.\nclients\n.\nfilter\n(\nc\n \n=\n \nc\n.\nid\n \n===\n \noptions\n.\nclientId\n).\nlength\n \n===\n \n0\n;\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \n// server-side\n\n\nonInit\n \n(\noptions\n: \nany\n)\n \n{\n\n    \nthis\n.\npassword\n \n=\n \noptions\n.\npassword\n;\n\n\n}\n\n\n\nrequestJoin\n \n(\noptions\n: \nany\n)\n \n{\n\n    \n// Private room. Only accept connections with the correct password.\n\n    \nreturn\n \nthis\n.\npassword\n \n===\n \noptions\n.\npassword\n;\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n3.\n If \nrequestJoin\n succeeds, \nRoom#onJoin()\n will be called with the \nclient\n reference and \noptions\n given by the client.\n\n\n4.\n If \nrequestJoin\n fails on every available room instance, a new instance will be spawned for that client. In case \nrequestJoin\n fails again, the client will receive an \n\"error\"\n event.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \n// client-side\n\n\nroom\n.\nonError\n.\nadd\n(\nfunction\n(\nerr\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nerror ocurred:\n,\n \nerr\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \n// client-side\n\n\nroom\n.\nOnError\n \n+=\n \n(\nobject\n \nsender\n,\n \nMessageEventArgs\n \ne\n)\n \n=\n \nDebug\n.\nLog\n(\ne\n.\ndata\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nRanked matches\n\n\nAs an alternative to returning \ntrue\n or \nfalse\n on \nrequestJoin\n, you can provide a number between \n0\n and \n1\n to manage priority. The match-making service will select the highest number for the new user to connect.\n\n\nOn this example, we're prioritizing rooms with the fewer number of clients. You can write your own logic to calculate the average skill level of your user, for example.\n\n\nclass\n \nMyRoomHandler\n \nextends\n \nRoom\n \n{\n\n  \n// maximum of 10 clients allowed on this room.\n\n  \nmaxClients\n \n=\n \n10\n;\n\n\n  \nrequestJoin\n \n(\noptions\n: \nany\n)\n \n{\n\n    \nreturn\n \n1\n \n-\n \n(\nthis\n.\nclients\n.\nlength\n \n/\n \n10\n);\n\n  \n}\n\n\n}", 
            "title": "Matchmaking"
        }, 
        {
            "location": "/concept-matchmaking/#the-matchmaking-cycle", 
            "text": "1.  Client asks to connect into a specific room:  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             // client-side  let   room   =   client . join ( battle );  \n\n         \n    \n         \n             // client-side  Room   room   =   client . Join ( battle );  \n\n         \n    \n         \n    \n                 \n                      2.  Server will loop through all spawned room instances named  \"battle\"  and call  requestJoin  method against that instance.  \n                 \n                    \n         \n            \n         \n             Example 1 \n         \n    \n         \n             Example 2 \n         \n    \n         \n    \n         \n            \n         \n             // server-side  requestJoin   ( options :  any )   { \n     // Prevent the client from joining the same room from another browser tab \n     return   this . clients . filter ( c   =   c . id   ===   options . clientId ). length   ===   0 ;  }  \n\n         \n    \n         \n             // server-side  onInit   ( options :  any )   { \n     this . password   =   options . password ;  }  requestJoin   ( options :  any )   { \n     // Private room. Only accept connections with the correct password. \n     return   this . password   ===   options . password ;  }  \n\n         \n    \n         \n    \n                 \n                      3.  If  requestJoin  succeeds,  Room#onJoin()  will be called with the  client  reference and  options  given by the client.  4.  If  requestJoin  fails on every available room instance, a new instance will be spawned for that client. In case  requestJoin  fails again, the client will receive an  \"error\"  event.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             // client-side  room . onError . add ( function ( err )   { \n     console . log ( error ocurred: ,   err );  });  \n\n         \n    \n         \n             // client-side  room . OnError   +=   ( object   sender ,   MessageEventArgs   e )   =   Debug . Log ( e . data );", 
            "title": "The matchmaking cycle"
        }, 
        {
            "location": "/concept-matchmaking/#ranked-matches", 
            "text": "As an alternative to returning  true  or  false  on  requestJoin , you can provide a number between  0  and  1  to manage priority. The match-making service will select the highest number for the new user to connect.  On this example, we're prioritizing rooms with the fewer number of clients. You can write your own logic to calculate the average skill level of your user, for example.  class   MyRoomHandler   extends   Room   { \n   // maximum of 10 clients allowed on this room. \n   maxClients   =   10 ; \n\n   requestJoin   ( options :  any )   { \n     return   1   -   ( this . clients . length   /   10 ); \n   }  }", 
            "title": "Ranked matches"
        }, 
        {
            "location": "/concept-worker-processes/", 
            "text": "Worker processes\n\n\nClustered environment\n\n\nThe clustered environment is recommended for your production environment. To leverage from it, you'll need to use \nClusterServer\n class. \n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \ncluster\n \nfrom\n \ncluster\n;\n\n\nimport\n \n*\n \nas\n \npath\n \nfrom\n \npath\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n{\n \nClusterServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \nPORT\n \n=\n \n8080\n;\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n  \ngameServer\n.\nlisten\n(\nPORT\n);\n\n  \ngameServer\n.\nfork\n();\n\n\n\n}\n \nelse\n \n{\n\n  \nconst\n \napp\n \n=\n \nnew\n \nexpress\n();\n\n\n  \ngameServer\n.\nattach\n({\n \nserver\n: \napp\n \n});\n\n\n}\n\n\n\nconsole\n.\nlog\n(\n`Listening on \n${\n \nPORT\n \n}\n`\n);\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncluster\n \n=\n \nrequire\n(\ncluster\n);\n\n\nconst\n \npath\n \n=\n \nrequire\n(\npath\n);\n\n\nconst\n \nexpress\n \n=\n \nrequire\n(\nexpress\n);\n\n\nconst\n \nClusterServer\n \n=\n \nrequire\n(\ncolyseus\n).\nClusterServer\n;\n\n\n\nconst\n \nPORT\n \n=\n \n8080\n;\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n  \ngameServer\n.\nlisten\n(\nPORT\n);\n\n  \ngameServer\n.\nfork\n();\n\n\n\n}\n \nelse\n \n{\n\n  \nconst\n \napp\n \n=\n \nnew\n \nexpress\n();\n\n\n  \ngameServer\n.\nattach\n({\n \nserver\n: \napp\n \n});\n\n\n}\n\n\n\nconsole\n.\nlog\n(\n`Listening on \n${\n \nPORT\n \n}\n`\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nBy default, \nClusterServer\n spawn a worker process for each CPU available on the host machine.\n\n\n                +----------------+                                                      \n                | Master process |                                                      \n                +--------|-------+                                                      \n                         |                                                              \n              +----------+-----------+                                                  \n              | Match-making process |                                                  \n              +----------------------+                                                  \n                         |                                                              \n         +----------------                                                              \n         |                                                                              \n+--------|-------+----------------+----------------+                                    \n| Worker process | Worker process | Worker process |                                    \n+----------------+----------------+----------------+                                    \n  # FooRoom        # FooRoom        # QuxRoom                                           \n  # BarRoom                \n\n\n\n\n\nMaster process\n\n\nThe master process will handle redirecting the WebSocket connection to the suitable process. When not connected to a room, the Match-making process will be selected for that connection.\n\n\nMatch-making process\n\n\nThe Match-making process is responsible for responding to requests for joining a room/session. After the request has been completed, the client will establish a new WebSocket connection which will be redirected the Worker process that room is living in.\n\n\nWorker process\n\n\nEach Worker processes can handle multiple rooms / sessions.\n\n\nSingle process environment\n\n\nThe single process environment is lightweight and is best for local development and prototyping. You can deploy it on \nZeit Now\n or \nHeroku\n for free.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \nhttp\n \nfrom\n \nhttp\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \nport\n \n=\n \n8080\n;\n\n\nconst\n \nendpoint\n \n=\n \nlocalhost\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\n\n// Create HTTP \n WebSocket servers\n\n\nconst\n \nserver\n \n=\n \nhttp\n.\ncreateServer\n(\napp\n);\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n \nserver\n: \nserver\n \n});\n\n\n\n// Listen on port\n\n\ngameServer\n.\nlisten\n(\nport\n);\n\n\nconsole\n.\nlog\n(\n`Listening on http://\n${\n \nendpoint\n \n}\n:\n${\n \nport\n \n}\n`\n)\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \nhttp\n \n=\n \nrequire\n(\nhttp\n);\n\n\nconst\n \nexpress\n \n=\n \nrequire\n(\nexpress\n);\n\n\nconst\n \nServer\n \n=\n \nrequire\n(\ncolyseus\n).\nServer\n;\n\n\n\nconst\n \nport\n \n=\n \n8080\n;\n\n\nconst\n \nendpoint\n \n=\n \nlocalhost\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\n\n// Create HTTP \n WebSocket servers\n\n\nconst\n \nserver\n \n=\n \nhttp\n.\ncreateServer\n(\napp\n);\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n \nserver\n: \nserver\n \n});\n\n\n\n// Listen on port\n\n\ngameServer\n.\nlisten\n(\nport\n);\n\n\nconsole\n.\nlog\n(\n`Listening on http://\n${\n \nendpoint\n \n}\n:\n${\n \nport\n \n}\n`\n)", 
            "title": "Worker processes"
        }, 
        {
            "location": "/concept-worker-processes/#worker-processes", 
            "text": "", 
            "title": "Worker processes"
        }, 
        {
            "location": "/concept-worker-processes/#clustered-environment", 
            "text": "The clustered environment is recommended for your production environment. To leverage from it, you'll need to use  ClusterServer  class.   \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   cluster   from   cluster ;  import   *   as   path   from   path ;  import   *   as   express   from   express ;  import   {   ClusterServer   }   from   colyseus ;  const   PORT   =   8080 ;  const   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n   gameServer . listen ( PORT ); \n   gameServer . fork ();  }   else   { \n   const   app   =   new   express (); \n\n   gameServer . attach ({   server :  app   });  }  console . log ( `Listening on  ${   PORT   } ` );  \n\n         \n    \n         \n             const   cluster   =   require ( cluster );  const   path   =   require ( path );  const   express   =   require ( express );  const   ClusterServer   =   require ( colyseus ). ClusterServer ;  const   PORT   =   8080 ;  const   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n   gameServer . listen ( PORT ); \n   gameServer . fork ();  }   else   { \n   const   app   =   new   express (); \n\n   gameServer . attach ({   server :  app   });  }  console . log ( `Listening on  ${   PORT   } ` );  \n\n         \n    \n         \n    \n                 \n                      By default,  ClusterServer  spawn a worker process for each CPU available on the host machine.                  +----------------+                                                      \n                | Master process |                                                      \n                +--------|-------+                                                      \n                         |                                                              \n              +----------+-----------+                                                  \n              | Match-making process |                                                  \n              +----------------------+                                                  \n                         |                                                              \n         +----------------                                                              \n         |                                                                              \n+--------|-------+----------------+----------------+                                    \n| Worker process | Worker process | Worker process |                                    \n+----------------+----------------+----------------+                                    \n  # FooRoom        # FooRoom        # QuxRoom                                           \n  # BarRoom", 
            "title": "Clustered environment"
        }, 
        {
            "location": "/concept-worker-processes/#master-process", 
            "text": "The master process will handle redirecting the WebSocket connection to the suitable process. When not connected to a room, the Match-making process will be selected for that connection.", 
            "title": "Master process"
        }, 
        {
            "location": "/concept-worker-processes/#match-making-process", 
            "text": "The Match-making process is responsible for responding to requests for joining a room/session. After the request has been completed, the client will establish a new WebSocket connection which will be redirected the Worker process that room is living in.", 
            "title": "Match-making process"
        }, 
        {
            "location": "/concept-worker-processes/#worker-process", 
            "text": "Each Worker processes can handle multiple rooms / sessions.", 
            "title": "Worker process"
        }, 
        {
            "location": "/concept-worker-processes/#single-process-environment", 
            "text": "The single process environment is lightweight and is best for local development and prototyping. You can deploy it on  Zeit Now  or  Heroku  for free.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   http   from   http ;  import   *   as   express   from   express ;  import   {   Server   }   from   colyseus ;  const   port   =   8080 ;  const   endpoint   =   localhost ;  const   app   =   express ();  // Create HTTP   WebSocket servers  const   server   =   http . createServer ( app );  const   gameServer   =   new   Server ({   server :  server   });  // Listen on port  gameServer . listen ( port );  console . log ( `Listening on http:// ${   endpoint   } : ${   port   } ` )  \n\n         \n    \n         \n             const   http   =   require ( http );  const   express   =   require ( express );  const   Server   =   require ( colyseus ). Server ;  const   port   =   8080 ;  const   endpoint   =   localhost ;  const   app   =   express ();  // Create HTTP   WebSocket servers  const   server   =   http . createServer ( app );  const   gameServer   =   new   Server ({   server :  server   });  // Listen on port  gameServer . listen ( port );  console . log ( `Listening on http:// ${   endpoint   } : ${   port   } ` )", 
            "title": "Single process environment"
        }, 
        {
            "location": "/api-room/", 
            "text": "Server-side Room API\n\n\nConsidering that you already \nset up your server\n, now it's time to register session handlers, and start accepting connections from your users.\n\n\nYou'll define session handlers creating classes that extends from \nRoom\n.\n\n\nimport\n \n{\n \nRoom\n,\n \nClient\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nexport\n \nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \n// When room is initialized\n\n    \nonInit\n \n(\noptions\n: \nany\n)\n \n{\n \n}\n\n\n    \n// Checks if a new client is allowed to join. (default: `return true`)\n\n    \nrequestJoin\n \n(\noptions\n: \nany\n)\n \n{\n \n}\n\n\n    \n// When client successfully join the room\n\n    \nonJoin\n \n(\nclient\n: \nClient\n)\n \n{\n \n}\n\n\n    \n// When a client leaves the room\n\n    \nonLeave\n \n(\nclient\n: \nClient\n)\n \n{\n \n}\n\n\n    \n// When a client sends a message\n\n    \nonMessage\n \n(\nclient\n: \nClient\n,\n \ndata\n: \nany\n)\n \n{\n \n}\n\n\n    \n// Cleanup callback, called after there are no more clients in the room. (see `autoDispose`)\n\n    \nonDispose\n \n()\n \n{\n \n}\n\n\n}\n\n\n\n\n\n\nAbstract methods\n\n\nRoom handlers can implement all these methods.\n\n\nonInit (options)\n\n\nIs called once when room is initialized. You may specify custom initialization options when registering the room handler.\n\n\n\n\nTip\n\n\nThe \noptions\n will contain the merged values you specified on \nServer#register()\n + the options provided by the first client on \nclient.join()\n\n\n\n\nverifyClient (client, options)\n\n\nCan be used to verify authenticity of the client that's joining the room.\n\n\nIf left non-implemented it returns \ntrue\n, allowing any client to connect.\n\n\nSee \nauthentication\n section.\n\n\nrequestJoin (options)\n\n\nSynchronous function used to check if a new client is allowed to join.\n\n\nIf left non-implemented it returns \ntrue\n, allowing any client to connect.\n\n\nonJoin (client)\n\n\nIs called when client successfully join the room, after \nrequestJoin\n and \nverifyClient\n succeeded.\n\n\nonMessage (client, data)\n\n\nIs called when a client sends a message to the server. Here's where you'll process client actions to update the room's state.\n\n\nExample:\n\n\nonMessage\n \n(\nclient\n,\n \ndata\n)\n \n{\n\n    \nlet\n \nplayer\n \n=\n \nthis\n.\nplayersByClientId\n.\nget\n(\nclient\n);\n\n\n    \nif\n \n(\ndata\n.\ncommand\n \n===\n \nleft\n)\n \n{\n\n        \nplayer\n.\nx\n \n-=\n \n1\n;\n\n\n    \n}\n \nelse\n \nif\n \n(\ndata\n.\ncommand\n \n===\n \nright\n)\n \n{\n\n        \nplayer\n.\nx\n \n+=\n \n1\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nonLeave (client)\n\n\nIs called when a client leave the room.\n\n\nYou can define this function as \nasync\n. See \ngraceful shutdown\n\n\nonDispose ()\n\n\nCleanup callback, called after there are no more clients in the room.\n\n\nYou can define this function as \nasync\n. See \ngraceful shutdown\n\n\nPublic properties\n\n\nclients: WebSocket[]\n\n\nThe array of connected clients. See \nWeb-Socket Client\n.\n\n\nmaxClients: number\n\n\nMaximum number of clients allowed to connect into the room\n\n\npatchRate: number\n\n\nFrequency to send the room state to connected clients (in milliseconds)\n\n\nSee \nstate synchronization\n.\n\n\nautoDispose: boolean\n\n\nAutomatically dispose the room when last client disconnect. (default: \ntrue\n)\n\n\nclock: ClockTimer\n\n\nA \nClockTimer\n instance, used for\n\ntiming events\n.\n\n\nPublic methods\n\n\nRoom handlers have these methods available.\n\n\nsetState (object)\n\n\nSet the new room state.\n\n\n\n\nWarning\n\n\nDo not call this method for updates in the room state. The binary patch algorithm is re-set every time you call it.\n\n\n\n\n\n\nTip\n\n\nYou'll usually call this method only once (on \nRoom.onInit()\n) in your room handler.\n\n\n\n\nsetSimulationInterval (callback[, milliseconds=16.6])\n\n\n(Optional) Create the simulation interval that will change the state of the game. Default simulation interval: 16.6ms (60fps)\n\n\nsetPatchRate (milliseconds)\n\n\nSet frequency the patched state should be sent to all clients. (default: \n50\n = 20fps)\n\n\nsend (client, data)\n\n\nSend data to a particular client.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nServer\n\n        \n\n    \n        \n\n            \nClient: JavaScript\n\n        \n\n    \n        \n\n            \nClient: C#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nthis\n.\nsend\n(\nclient\n,\n \n{\n \nmessage\n:\n \nHello world!\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nonData\n.\nadd\n(\nfunction\n(\ndata\n)\n \n{\n\n    \nconsole\n.\nlog\n(\ndata\n);\n\n    \n// =\n {message: \nHello world!\n}\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnData\n \n+=\n \n(\nobject\n \nsender\n,\n \nMessageEventArgs\n \ne\n)\n \n=\n \nDebug\n.\nLog\n(\ne\n.\ndata\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nlock ()\n\n\nLocking the room will remove it from the pool of available rooms for new clients to connect to.\n\n\nunlock ()\n\n\nUnlocking the room returns it to the pool of available rooms for new clients to connect to.\n\n\nbroadcast ( data )\n\n\nSend raw data to all connected clients.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nServer\n\n        \n\n    \n        \n\n            \nClient: JavaScript\n\n        \n\n    \n        \n\n            \nClient: C#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nthis\n.\nbroadcast\n({\n \nmessage\n:\n \nHello world!\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nonData\n.\nadd\n(\nfunction\n(\ndata\n)\n \n{\n\n    \nconsole\n.\nlog\n(\ndata\n);\n\n    \n// =\n {message: \nHello world!\n}\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnData\n \n+=\n \n(\nobject\n \nsender\n,\n \nMessageEventArgs\n \ne\n)\n \n=\n \nDebug\n.\nLog\n(\ne\n.\ndata\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\ndisconnect ()\n\n\nDisconnect all clients, then dispose.", 
            "title": "Room"
        }, 
        {
            "location": "/api-room/#server-side-room-api", 
            "text": "Considering that you already  set up your server , now it's time to register session handlers, and start accepting connections from your users.  You'll define session handlers creating classes that extends from  Room .  import   {   Room ,   Client   }   from   colyseus ;  export   class   MyRoom   extends   Room   { \n     // When room is initialized \n     onInit   ( options :  any )   {   } \n\n     // Checks if a new client is allowed to join. (default: `return true`) \n     requestJoin   ( options :  any )   {   } \n\n     // When client successfully join the room \n     onJoin   ( client :  Client )   {   } \n\n     // When a client leaves the room \n     onLeave   ( client :  Client )   {   } \n\n     // When a client sends a message \n     onMessage   ( client :  Client ,   data :  any )   {   } \n\n     // Cleanup callback, called after there are no more clients in the room. (see `autoDispose`) \n     onDispose   ()   {   }  }", 
            "title": "Server-side Room API"
        }, 
        {
            "location": "/api-room/#abstract-methods", 
            "text": "Room handlers can implement all these methods.", 
            "title": "Abstract methods"
        }, 
        {
            "location": "/api-room/#oninit-options", 
            "text": "Is called once when room is initialized. You may specify custom initialization options when registering the room handler.   Tip  The  options  will contain the merged values you specified on  Server#register()  + the options provided by the first client on  client.join()", 
            "title": "onInit (options)"
        }, 
        {
            "location": "/api-room/#verifyclient-client-options", 
            "text": "Can be used to verify authenticity of the client that's joining the room.  If left non-implemented it returns  true , allowing any client to connect.  See  authentication  section.", 
            "title": "verifyClient (client, options)"
        }, 
        {
            "location": "/api-room/#requestjoin-options", 
            "text": "Synchronous function used to check if a new client is allowed to join.  If left non-implemented it returns  true , allowing any client to connect.", 
            "title": "requestJoin (options)"
        }, 
        {
            "location": "/api-room/#onjoin-client", 
            "text": "Is called when client successfully join the room, after  requestJoin  and  verifyClient  succeeded.", 
            "title": "onJoin (client)"
        }, 
        {
            "location": "/api-room/#onmessage-client-data", 
            "text": "Is called when a client sends a message to the server. Here's where you'll process client actions to update the room's state.  Example:  onMessage   ( client ,   data )   { \n     let   player   =   this . playersByClientId . get ( client ); \n\n     if   ( data . command   ===   left )   { \n         player . x   -=   1 ; \n\n     }   else   if   ( data . command   ===   right )   { \n         player . x   +=   1 ; \n     }  }", 
            "title": "onMessage (client, data)"
        }, 
        {
            "location": "/api-room/#onleave-client", 
            "text": "Is called when a client leave the room.  You can define this function as  async . See  graceful shutdown", 
            "title": "onLeave (client)"
        }, 
        {
            "location": "/api-room/#ondispose", 
            "text": "Cleanup callback, called after there are no more clients in the room.  You can define this function as  async . See  graceful shutdown", 
            "title": "onDispose ()"
        }, 
        {
            "location": "/api-room/#public-properties", 
            "text": "", 
            "title": "Public properties"
        }, 
        {
            "location": "/api-room/#clients-websocket", 
            "text": "The array of connected clients. See  Web-Socket Client .", 
            "title": "clients: WebSocket[]"
        }, 
        {
            "location": "/api-room/#maxclients-number", 
            "text": "Maximum number of clients allowed to connect into the room", 
            "title": "maxClients: number"
        }, 
        {
            "location": "/api-room/#patchrate-number", 
            "text": "Frequency to send the room state to connected clients (in milliseconds)  See  state synchronization .", 
            "title": "patchRate: number"
        }, 
        {
            "location": "/api-room/#autodispose-boolean", 
            "text": "Automatically dispose the room when last client disconnect. (default:  true )", 
            "title": "autoDispose: boolean"
        }, 
        {
            "location": "/api-room/#clock-clocktimer", 
            "text": "A  ClockTimer  instance, used for timing events .", 
            "title": "clock: ClockTimer"
        }, 
        {
            "location": "/api-room/#public-methods", 
            "text": "Room handlers have these methods available.", 
            "title": "Public methods"
        }, 
        {
            "location": "/api-room/#setstate-object", 
            "text": "Set the new room state.   Warning  Do not call this method for updates in the room state. The binary patch algorithm is re-set every time you call it.    Tip  You'll usually call this method only once (on  Room.onInit() ) in your room handler.", 
            "title": "setState (object)"
        }, 
        {
            "location": "/api-room/#setsimulationinterval-callback-milliseconds166", 
            "text": "(Optional) Create the simulation interval that will change the state of the game. Default simulation interval: 16.6ms (60fps)", 
            "title": "setSimulationInterval (callback[, milliseconds=16.6])"
        }, 
        {
            "location": "/api-room/#setpatchrate-milliseconds", 
            "text": "Set frequency the patched state should be sent to all clients. (default:  50  = 20fps)", 
            "title": "setPatchRate (milliseconds)"
        }, 
        {
            "location": "/api-room/#send-client-data", 
            "text": "Send data to a particular client.  \n                 \n                    \n         \n            \n         \n             Server \n         \n    \n         \n             Client: JavaScript \n         \n    \n         \n             Client: C# \n         \n    \n         \n    \n         \n            \n         \n             this . send ( client ,   {   message :   Hello world!   });  \n\n         \n    \n         \n             room . onData . add ( function ( data )   { \n     console . log ( data ); \n     // =  {message:  Hello world! }  });  \n\n         \n    \n         \n             room . OnData   +=   ( object   sender ,   MessageEventArgs   e )   =   Debug . Log ( e . data );", 
            "title": "send (client, data)"
        }, 
        {
            "location": "/api-room/#lock", 
            "text": "Locking the room will remove it from the pool of available rooms for new clients to connect to.", 
            "title": "lock ()"
        }, 
        {
            "location": "/api-room/#unlock", 
            "text": "Unlocking the room returns it to the pool of available rooms for new clients to connect to.", 
            "title": "unlock ()"
        }, 
        {
            "location": "/api-room/#broadcast-data", 
            "text": "Send raw data to all connected clients.  \n                 \n                    \n         \n            \n         \n             Server \n         \n    \n         \n             Client: JavaScript \n         \n    \n         \n             Client: C# \n         \n    \n         \n    \n         \n            \n         \n             this . broadcast ({   message :   Hello world!   });  \n\n         \n    \n         \n             room . onData . add ( function ( data )   { \n     console . log ( data ); \n     // =  {message:  Hello world! }  });  \n\n         \n    \n         \n             room . OnData   +=   ( object   sender ,   MessageEventArgs   e )   =   Debug . Log ( e . data );", 
            "title": "broadcast ( data )"
        }, 
        {
            "location": "/api-room/#disconnect", 
            "text": "Disconnect all clients, then dispose.", 
            "title": "disconnect ()"
        }, 
        {
            "location": "/api-timing-events/", 
            "text": "For \ntiming events\n,\nit's recommended to use the \nClockTimer\n methods.\n\n\n\n\nImportant\n\n\nThe built-in\n\nsetTimeout\n\nand\n\nsetInterval\n\nmethods rely on CPU load, which may delay an unexpected amount of time to execute.\n\n\n\n\nClockTimer\n\n\nPublic methods\n\n\nclock.setInterval(callback, time, ...args): Delayed\n\n\nThe \nsetInterval()\n method repeatedly calls a function or executes a code\nsnippet, with a fixed time delay between each call. It returns\n\nDelayed\n instance which identifies the interval, so you can\nmanipulate it later.\n\n\nclock.setTimeout(callback, time, ...args): Delayed\n\n\nThe \nsetTimeout()\n method sets a timer which executes a function or specified\npiece of code once after the timer expires. It returns \nDelayed\n\ninstance which identifies the interval, so you can manipulate it later.\n\n\nclock.clear()\n\n\nClear all intervals and timeouts registered with \nclock.setInterval()\n and \nclock.setTimeout()\n.\n\n\nclock.start()\n\n\nStart counting time.\n\n\nclock.stop()\n\n\nStop counting time.\n\n\nclock.tick()\n\n\nThis method is called automatically at every simulation interval step. All\n\nDelayed\n instances are checked during \ntick\n.\n\n\n\n\nTip\n\n\nSee \nRoom#setSimiulationInterval()\n for more details.\n\n\n\n\nPublic properties\n\n\nclock.elapsedTime\n\n\nElased time in milliseconds since \nclock.start()\n method was called. Read only.\n\n\nclock.currentTime\n\n\nCurrent time in milliseconds. Read only.\n\n\nclock.deltaTime\n\n\nThe difference in milliseconds between the last and current \nclock.tick()\n call. Read only.\n\n\nDelayed\n\n\nDelayed instances are created from\n\nclock.setInterval()\n or\n\nclock.setTimeout()\n methods.\n\n\nPublic methods\n\n\ndelayed.clear()\n\n\nClears the timeout or interval.\n\n\ndelayed.reset()\n\n\nReset the elapsed time.\n\n\nPublic properties\n\n\ndelayed.active: boolean\n\n\nReturns \ntrue\n if timer is still running.", 
            "title": "Timing events"
        }, 
        {
            "location": "/api-timing-events/#clocktimer", 
            "text": "", 
            "title": "ClockTimer"
        }, 
        {
            "location": "/api-timing-events/#public-methods", 
            "text": "", 
            "title": "Public methods"
        }, 
        {
            "location": "/api-timing-events/#clocksetintervalcallback-time-args-delayed", 
            "text": "The  setInterval()  method repeatedly calls a function or executes a code\nsnippet, with a fixed time delay between each call. It returns Delayed  instance which identifies the interval, so you can\nmanipulate it later.", 
            "title": "clock.setInterval(callback, time, ...args): Delayed"
        }, 
        {
            "location": "/api-timing-events/#clocksettimeoutcallback-time-args-delayed", 
            "text": "The  setTimeout()  method sets a timer which executes a function or specified\npiece of code once after the timer expires. It returns  Delayed \ninstance which identifies the interval, so you can manipulate it later.", 
            "title": "clock.setTimeout(callback, time, ...args): Delayed"
        }, 
        {
            "location": "/api-timing-events/#clockclear", 
            "text": "Clear all intervals and timeouts registered with  clock.setInterval()  and  clock.setTimeout() .", 
            "title": "clock.clear()"
        }, 
        {
            "location": "/api-timing-events/#clockstart", 
            "text": "Start counting time.", 
            "title": "clock.start()"
        }, 
        {
            "location": "/api-timing-events/#clockstop", 
            "text": "Stop counting time.", 
            "title": "clock.stop()"
        }, 
        {
            "location": "/api-timing-events/#clocktick", 
            "text": "This method is called automatically at every simulation interval step. All Delayed  instances are checked during  tick .   Tip  See  Room#setSimiulationInterval()  for more details.", 
            "title": "clock.tick()"
        }, 
        {
            "location": "/api-timing-events/#public-properties", 
            "text": "", 
            "title": "Public properties"
        }, 
        {
            "location": "/api-timing-events/#clockelapsedtime", 
            "text": "Elased time in milliseconds since  clock.start()  method was called. Read only.", 
            "title": "clock.elapsedTime"
        }, 
        {
            "location": "/api-timing-events/#clockcurrenttime", 
            "text": "Current time in milliseconds. Read only.", 
            "title": "clock.currentTime"
        }, 
        {
            "location": "/api-timing-events/#clockdeltatime", 
            "text": "The difference in milliseconds between the last and current  clock.tick()  call. Read only.", 
            "title": "clock.deltaTime"
        }, 
        {
            "location": "/api-timing-events/#delayed", 
            "text": "Delayed instances are created from clock.setInterval()  or clock.setTimeout()  methods.", 
            "title": "Delayed"
        }, 
        {
            "location": "/api-timing-events/#public-methods_1", 
            "text": "", 
            "title": "Public methods"
        }, 
        {
            "location": "/api-timing-events/#delayedclear", 
            "text": "Clears the timeout or interval.", 
            "title": "delayed.clear()"
        }, 
        {
            "location": "/api-timing-events/#delayedreset", 
            "text": "Reset the elapsed time.", 
            "title": "delayed.reset()"
        }, 
        {
            "location": "/api-timing-events/#public-properties_1", 
            "text": "", 
            "title": "Public properties"
        }, 
        {
            "location": "/api-timing-events/#delayedactive-boolean", 
            "text": "Returns  true  if timer is still running.", 
            "title": "delayed.active: boolean"
        }, 
        {
            "location": "/api-room-state/", 
            "text": "The room handlers are \nstateful\n in Colyseus. Each room holds its own state. To allow \nsynchronization\n, you \nmust\n mutate the room's state. The server automatically broadcasts the changes to all connected clients at each patch interval.\n\n\n\n\nTip\n\n\n\n\nFor synchronization with the client-side, see \nclient-side state synchronization\n.\n\n\nSee Colyseus' technical approach on \nstate synchronization\n.\n\n\n\n\n\n\nRaw Object State\n\n\nThe simplest way to deal with the room state is using a raw JavaScript objects directly in the \nRoom\n handler.\n\n\nOn the following example, you'll see:\n\n\n\n\nCreating player upon client connection.\n\n\nHandling client-side actions and updating the state to move \nx\n position.\n\n\nRemoving player upon client disconnection.\n\n\n\n\nimport\n \n{\n \nRoom\n,\n \nClient\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nexport\n \nclass\n \nBattleRoom\n \nextends\n \nRoom\n \n{\n\n\n  \nonInit\n \n(\noptions\n: \nany\n)\n \n{\n\n    \nthis\n.\nsetState\n({\n\n      \nplayers\n:\n \n{}\n\n    \n});\n\n  \n}\n\n\n  \nonJoin\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nstate\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n]\n \n=\n \n{\n\n      \nx\n: \n0\n,\n\n      \ny\n: \n0\n\n    \n};\n\n  \n}\n\n\n  \nonLeave\n \n(\nclient\n)\n \n{\n\n    \ndelete\n \nthis\n.\nstate\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n];\n\n  \n}\n\n\n  \nonMessage\n \n(\nclient\n,\n \ndata\n)\n \n{\n\n    \nif\n \n(\ndata\n.\naction\n \n===\n \nleft\n)\n \n{\n\n      \nthis\n.\nstate\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n].\nx\n \n-=\n \n1\n;\n\n\n    \n}\n \nelse\n \nif\n \n(\ndata\n.\naction\n \n===\n \nright\n)\n \n{\n\n      \nthis\n.\nstate\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n].\nx\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nYour Own Data Structures\n\n\nWhilst it's possible to use raw data directly on \nthis.state\n. The recommended way to handle your state is through your own data structures. By creating your own structures, you can have a more decoupled structure to represent your state.\n\n\nOn the following (rewritten) example, you'll see:\n\n\n\n\nA clean \nBattleRoom\n implementation, directly coupled to the state structure.\n\n\nA large data structure holding the entire room state (\nBattleState\n)\n\n\nUsage of built-in \nEntityMap\n type.\n\n\nMethods manipulating smaller data structures\n\n\n\n\n\n\nA small decoupled data structure representing a single entity (\nPlayer\n)\n\n\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nBattleRoom.ts\n\n        \n\n    \n        \n\n            \nBattleState.ts\n\n        \n\n    \n        \n\n            \nPlayer.ts\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \n// BattleRoom.ts\n\n\nimport\n \n{\n \nRoom\n,\n \nClient\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \nBattleState\n \n}\n \nfrom\n \n./BattleState\n;\n\n\n\nexport\n \nclass\n \nBattleRoom\n \nextends\n \nRoom\nBattleState\n \n{\n\n\n  \nonInit\n \n(\noptions\n: \nany\n)\n \n{\n\n    \nthis\n.\nsetState\n(\nnew\n \nBattleState\n());\n\n  \n}\n\n\n  \nonJoin\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nstate\n.\naddPlayer\n(\nclient\n);\n\n  \n}\n\n\n  \nonLeave\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nstate\n.\nremovePlayer\n(\nclient\n);\n\n  \n}\n\n\n  \nonMessage\n \n(\nclient\n,\n \ndata\n)\n \n{\n\n    \nif\n \n(\ndata\n.\naction\n)\n \n{\n\n      \nthis\n.\nstate\n.\nmovePlayer\n(\nclient\n,\n \ndata\n.\naction\n);\n\n    \n}\n\n  \n}\n\n\n  \nonDispose\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\nDispose BattleRoom\n);\n\n  \n}\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \n// BattleState.ts\n\n\nimport\n \n{\n \nEntityMap\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \nPlayer\n \n}\n \nfrom\n \n./Player\n;\n\n\n\nexport\n \nclass\n \nBattleState\n \n{\n\n  \nplayers\n: \nEntityMap\nPlayer\n \n=\n \n{};\n\n\n  \naddPlayer\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nplayers\n[\n \nclient\n.\nsesssionId\n \n]\n \n=\n \nnew\n \nPlayer\n(\n0\n,\n \n0\n);\n\n  \n}\n\n\n  \nremovePlayer\n \n(\nclient\n)\n \n{\n\n    \ndelete\n \nthis\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n];\n\n  \n}\n\n\n  \nmovePlayer\n \n(\nclient\n,\n \naction\n)\n \n{\n\n    \nif\n \n(\naction\n \n===\n \nleft\n)\n \n{\n\n      \nthis\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n].\nx\n \n-=\n \n1\n;\n\n\n    \n}\n \nelse\n \nif\n \n(\naction\n \n===\n \nright\n)\n \n{\n\n      \nthis\n.\nplayers\n[\n \nclient\n.\nsessionId\n \n].\nx\n \n+=\n \n1\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \n// Player.ts\n\n\nexport\n \nclass\n \nPlayer\n \n{\n\n  \nconstructor\n \n(\n\n    \npublic\n \nx\n: \nnumber\n,\n\n    \npublic\n \ny\n: \nnumber\n\n  \n)\n \n{\n\n    \nthis\n.\nx\n \n=\n \nx\n;\n\n    \nthis\n.\ny\n \n=\n \ny\n;\n\n  \n}\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nMap of entities (\nEntityMap\n)\n\n\nThe \nEntityMap\n is useful to have strong data typing during development. Since you cannot use \nMap\n to describe public synchronizeable properties (see \navoid using \nMap\n and \nSet\n), the \nEntityMap\n is used to describe a simple map of keys (\nstring\n) to a custom type (\nT\n).\n\n\ntype\n \nEntityMap\nT\n \n=\n \n{[\n \nentityId\n:\nstring\n \n]\n:\n \nT\n};\n\n\n\n\n\n\nYour state will usualy have at least one usage of \nEntityMap\n for the map of connected clients. As described on \nprevious example\n.\n\n\nPrivate variables (\n@nosync\n)\n\n\nTo prevent private properties from leaking into your clients' state, you need to set those properties as \nnon-enumerable\n. The decorator \n@nosync\n is a syntax sugar for this purpose.\n\n\nexport\n \nclass\n \nPlayer\n \n{\n\n  \nx\n: \nnumber\n;\n\n  \ny\n: \nnumber\n;\n\n\n  \n@nosync\n\n  \nwontBeSynched\n: \nstring\n \n=\n \nThis property won\nt be synched with clients\n;\n\n\n}\n\n\n\n\n\n\nAvoid using \nMap\n, \nSet\n\n\nAvoid using \nMap\n and \nSet\n for public, synchronizeable, properties.\n\n\nUnfortunately, the JavaScript built-in types \nMap\n and \nSet\n aren't serializeable by default. This means MessagePack cannot encode them properly.\n\n\nSee why:\n\n\nvar\n \nmyMap\n \n=\n \nnew\n \nMap\n([[\nk1\n,\n \nv1\n],\n \n[\nk2\n,\n \nv2\n]]);\n\n\n// =\n Map(2) {\nkey\n =\n \nvalue\n, \nkey2\n =\n \nvalue2\n}\n\n\nJSON\n.\nstringify\n(\nmyMap\n);\n\n\n// =\n \n{}\n\n\n\n\n\n\nYou're encourage to use them for private variables, though. See \n@nosync\n for not synchronizeable properties.\n\n\nAvoid mutating arrays\n\n\n\n\npush\ning new entries is OK - the clients will receive a single \n\"add\"\n operation.\n\n\npop\ning the last entry is OK - the clients will receive a single \n\"remove\"\n operation.\n\n\n\n\nRemoving or inserting entries in-between will generate one \n\"replace\"\n operation for each entry that had the index changed. Be careful to handle these changes in the client-side properly.", 
            "title": "State management"
        }, 
        {
            "location": "/api-room-state/#raw-object-state", 
            "text": "The simplest way to deal with the room state is using a raw JavaScript objects directly in the  Room  handler.  On the following example, you'll see:   Creating player upon client connection.  Handling client-side actions and updating the state to move  x  position.  Removing player upon client disconnection.   import   {   Room ,   Client   }   from   colyseus ;  export   class   BattleRoom   extends   Room   { \n\n   onInit   ( options :  any )   { \n     this . setState ({ \n       players :   {} \n     }); \n   } \n\n   onJoin   ( client )   { \n     this . state . players [   client . sessionId   ]   =   { \n       x :  0 , \n       y :  0 \n     }; \n   } \n\n   onLeave   ( client )   { \n     delete   this . state . players [   client . sessionId   ]; \n   } \n\n   onMessage   ( client ,   data )   { \n     if   ( data . action   ===   left )   { \n       this . state . players [   client . sessionId   ]. x   -=   1 ; \n\n     }   else   if   ( data . action   ===   right )   { \n       this . state . players [   client . sessionId   ]. x   +=   1 ; \n     } \n   }  }", 
            "title": "Raw Object State"
        }, 
        {
            "location": "/api-room-state/#your-own-data-structures", 
            "text": "Whilst it's possible to use raw data directly on  this.state . The recommended way to handle your state is through your own data structures. By creating your own structures, you can have a more decoupled structure to represent your state.  On the following (rewritten) example, you'll see:   A clean  BattleRoom  implementation, directly coupled to the state structure.  A large data structure holding the entire room state ( BattleState )  Usage of built-in  EntityMap  type.  Methods manipulating smaller data structures    A small decoupled data structure representing a single entity ( Player )   \n                 \n                    \n         \n            \n         \n             BattleRoom.ts \n         \n    \n         \n             BattleState.ts \n         \n    \n         \n             Player.ts \n         \n    \n         \n    \n         \n            \n         \n             // BattleRoom.ts  import   {   Room ,   Client   }   from   colyseus ;  import   {   BattleState   }   from   ./BattleState ;  export   class   BattleRoom   extends   Room BattleState   { \n\n   onInit   ( options :  any )   { \n     this . setState ( new   BattleState ()); \n   } \n\n   onJoin   ( client )   { \n     this . state . addPlayer ( client ); \n   } \n\n   onLeave   ( client )   { \n     this . state . removePlayer ( client ); \n   } \n\n   onMessage   ( client ,   data )   { \n     if   ( data . action )   { \n       this . state . movePlayer ( client ,   data . action ); \n     } \n   } \n\n   onDispose   ()   { \n     console . log ( Dispose BattleRoom ); \n   }  }  \n\n         \n    \n         \n             // BattleState.ts  import   {   EntityMap   }   from   colyseus ;  import   {   Player   }   from   ./Player ;  export   class   BattleState   { \n   players :  EntityMap Player   =   {}; \n\n   addPlayer   ( client )   { \n     this . players [   client . sesssionId   ]   =   new   Player ( 0 ,   0 ); \n   } \n\n   removePlayer   ( client )   { \n     delete   this . players [   client . sessionId   ]; \n   } \n\n   movePlayer   ( client ,   action )   { \n     if   ( action   ===   left )   { \n       this . players [   client . sessionId   ]. x   -=   1 ; \n\n     }   else   if   ( action   ===   right )   { \n       this . players [   client . sessionId   ]. x   +=   1 ; \n     } \n   }  }  \n\n         \n    \n         \n             // Player.ts  export   class   Player   { \n   constructor   ( \n     public   x :  number , \n     public   y :  number \n   )   { \n     this . x   =   x ; \n     this . y   =   y ; \n   }  }", 
            "title": "Your Own Data Structures"
        }, 
        {
            "location": "/api-room-state/#map-of-entities-entitymap", 
            "text": "The  EntityMap  is useful to have strong data typing during development. Since you cannot use  Map  to describe public synchronizeable properties (see  avoid using  Map  and  Set ), the  EntityMap  is used to describe a simple map of keys ( string ) to a custom type ( T ).  type   EntityMap T   =   {[   entityId : string   ] :   T };   Your state will usualy have at least one usage of  EntityMap  for the map of connected clients. As described on  previous example .", 
            "title": "Map of entities (EntityMap)"
        }, 
        {
            "location": "/api-room-state/#private-variables-nosync", 
            "text": "To prevent private properties from leaking into your clients' state, you need to set those properties as  non-enumerable . The decorator  @nosync  is a syntax sugar for this purpose.  export   class   Player   { \n   x :  number ; \n   y :  number ; \n\n   @nosync \n   wontBeSynched :  string   =   This property won t be synched with clients ;  }", 
            "title": "Private variables (@nosync)"
        }, 
        {
            "location": "/api-room-state/#avoid-using-map-set", 
            "text": "Avoid using  Map  and  Set  for public, synchronizeable, properties.  Unfortunately, the JavaScript built-in types  Map  and  Set  aren't serializeable by default. This means MessagePack cannot encode them properly.  See why:  var   myMap   =   new   Map ([[ k1 ,   v1 ],   [ k2 ,   v2 ]]);  // =  Map(2) { key  =   value ,  key2  =   value2 }  JSON . stringify ( myMap );  // =   {}   You're encourage to use them for private variables, though. See  @nosync  for not synchronizeable properties.", 
            "title": "Avoid using Map, Set"
        }, 
        {
            "location": "/api-room-state/#avoid-mutating-arrays", 
            "text": "push ing new entries is OK - the clients will receive a single  \"add\"  operation.  pop ing the last entry is OK - the clients will receive a single  \"remove\"  operation.   Removing or inserting entries in-between will generate one  \"replace\"  operation for each entry that had the index changed. Be careful to handle these changes in the client-side properly.", 
            "title": "Avoid mutating arrays"
        }, 
        {
            "location": "/api-server/", 
            "text": "Web-Socket Server\n\n\nThe \nServer\n and \nClusterServer\n have pretty much the same API. \n\n\nThey're responsible for providing the WebSocket server to enable communication between server and client.\n\n\nServer\n\n\nRecommended for development and prototyping environments.\n\n\nregister (name: string, handler: Room, options?: any)\n\n\nRegister a new session handler.\n\n\nParameters:\n\n\n\n\nname: string\n - The public name of the room. You'll use this name when joining the room from the client-side.\n\n\nhandler: Room\n - Reference to the \nRoom\n handler class.\n\n\noptions?: any\n - Custom options for room initialization.\n\n\n\n\n// Register \nchat\n room\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n);\n\n\n\n// Register \nbattle\n room\n\n\ngameServer\n.\nregister\n(\nbattle\n,\n \nBattleRoom\n);\n\n\n\n\n\n\n\n\nTip\n\n\nYou may register the same room handler multiple times with different \noptions\n. When \nRoom#onInit()\n is called, the \noptions\n will contain the merged values you specified on \nServer#register()\n + the options provided by the first client on \nclient.join()\n\n\n\n\nListening to matchmake events\n\n\nThe \nregister\n method will return the registered handler instance, which you can listen to match-making events from outside the room instance scope. Such as:\n\n\n\n\n\"create\"\n - when a room has been created\n\n\n\"dispose\"\n - when a room has been disposed\n\n\n\"join\"\n - when a client join a room\n\n\n\"leave\"\n - when a client leave a room\n\n\n\"lock\"\n - when a room has been locked\n\n\n\"unlock\"\n - when a room has been unlocked\n\n\n\n\nUsage:\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n).\n\n  \non\n(\ncreate\n,\n \n(\nroom\n)\n \n=\n \nconsole\n.\nlog\n(\nroom created:\n,\n \nroom\n.\nroomId\n)).\n\n  \non\n(\ndispose\n,\n \n(\nroom\n)\n \n=\n \nconsole\n.\nlog\n(\nroom disposed:\n,\n \nroom\n.\nroomId\n)).\n\n  \non\n(\njoin\n,\n \n(\nroom\n,\n \nclient\n)\n \n=\n \nconsole\n.\nlog\n(\nclient\n.\nid\n,\n \njoined\n,\n \nroom\n.\nroomId\n)).\n\n  \non\n(\nleave\n,\n \n(\nroom\n,\n \nclient\n)\n \n=\n \nconsole\n.\nlog\n(\nclient\n.\nid\n,\n \nleft\n,\n \nroom\n.\nroomId\n));\n\n\n\n\n\n\n\n\nWarning\n\n\nIt's completely discouraged to manipulate a room's state through these events. Use the \nabstract methods\n in your room handler instead.\n\n\n\n\nattach (options: any)\n\n\nAttaches or creates the WebSocket server.\n\n\n\n\noptions.server\n: The HTTP server to attach the WebSocket server on.\n\n\noptions.ws\n: An existing WebSocket server to be re-used.\n\n\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nExpress\n\n        \n\n    \n        \n\n            \nhttp.createServer\n\n        \n\n    \n        \n\n            \nWebSocket.Server\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \napp\n \n=\n \nnew\n \nexpress\n();\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n();\n\n\n\ngameServer\n.\nattach\n({\n \nserver\n:\n \napp\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n*\n \nas\n \nhttp\n \nfrom\n \nhttp\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \nhttpServer\n \n=\n \nhttp\n.\ncreateServer\n();\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n();\n\n\n\ngameServer\n.\nattach\n({\n \nserver\n:\n \nhttpServer\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n*\n \nas\n \nhttp\n \nfrom\n \nhttp\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n*\n \nas\n \nws\n \nfrom\n \nws\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\nconst\n \nserver\n \n=\n \nhttp\n.\ncreateServer\n(\napp\n);\n\n\nconst\n \nwss\n \n=\n \nnew\n \nWebSocket\n.\nServer\n({\n\n    \n// your custom WebSocket.Server setup.\n\n\n});\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n();\n\n\ngameServer\n.\nattach\n({\n \nws\n:\n \nwss\n \n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nlisten (port: number)\n\n\nBinds the WebSocket server into the specified port.\n\n\nonShutdown (callback: Function)\n\n\nRegister a callback that should be called before the process shut down. See \ngraceful shutdown\n for more details.\n\n\nClusterServer\n\n\nRecommended for production environment. \n\n\nThe \nClusterServer\n has the same functionality of \nServer\n, with some caveats. You'll need to use the \n\"cluster\"\n module by yourself and call its methods in the right node type. \n\n\nSee \nClustered environment\n for more details.\n\n\nfork (workers?: number)\n\n\nSpecify the number of session workers to spawn. By default it uses the number of available CPUs.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \ncluster\n \nfrom\n \ncluster\n;\n\n\nimport\n \n{\n \nClusterServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nlet\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n    \ngameServer\n.\nlisten\n(\n8080\n);\n\n    \ngameServer\n.\nfork\n(\n4\n);\n\n\n\n}\n \nelse\n \n{\n\n    \n// ...\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncluster\n \n=\n \nrequire\n(\ncluster\n);\n\n\nconst\n \nClusterServer\n \n=\n \nrequire\n(\ncolyseus\n).\nClusterServer\n;\n\n\n\nlet\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n    \ngameServer\n.\nlisten\n(\n8080\n);\n\n    \ngameServer\n.\nfork\n(\n4\n);\n\n\n\n}\n \nelse\n \n{\n\n    \n// ...\n\n\n}", 
            "title": "Web-Socket Server"
        }, 
        {
            "location": "/api-server/#web-socket-server", 
            "text": "The  Server  and  ClusterServer  have pretty much the same API.   They're responsible for providing the WebSocket server to enable communication between server and client.", 
            "title": "Web-Socket Server"
        }, 
        {
            "location": "/api-server/#server", 
            "text": "Recommended for development and prototyping environments.", 
            "title": "Server"
        }, 
        {
            "location": "/api-server/#register-name-string-handler-room-options-any", 
            "text": "Register a new session handler.  Parameters:   name: string  - The public name of the room. You'll use this name when joining the room from the client-side.  handler: Room  - Reference to the  Room  handler class.  options?: any  - Custom options for room initialization.   // Register  chat  room  gameServer . register ( chat ,   ChatRoom );  // Register  battle  room  gameServer . register ( battle ,   BattleRoom );    Tip  You may register the same room handler multiple times with different  options . When  Room#onInit()  is called, the  options  will contain the merged values you specified on  Server#register()  + the options provided by the first client on  client.join()", 
            "title": "register (name: string, handler: Room, options?: any)"
        }, 
        {
            "location": "/api-server/#listening-to-matchmake-events", 
            "text": "The  register  method will return the registered handler instance, which you can listen to match-making events from outside the room instance scope. Such as:   \"create\"  - when a room has been created  \"dispose\"  - when a room has been disposed  \"join\"  - when a client join a room  \"leave\"  - when a client leave a room  \"lock\"  - when a room has been locked  \"unlock\"  - when a room has been unlocked   Usage:  gameServer . register ( chat ,   ChatRoom ). \n   on ( create ,   ( room )   =   console . log ( room created: ,   room . roomId )). \n   on ( dispose ,   ( room )   =   console . log ( room disposed: ,   room . roomId )). \n   on ( join ,   ( room ,   client )   =   console . log ( client . id ,   joined ,   room . roomId )). \n   on ( leave ,   ( room ,   client )   =   console . log ( client . id ,   left ,   room . roomId ));    Warning  It's completely discouraged to manipulate a room's state through these events. Use the  abstract methods  in your room handler instead.", 
            "title": "Listening to matchmake events"
        }, 
        {
            "location": "/api-server/#attach-options-any", 
            "text": "Attaches or creates the WebSocket server.   options.server : The HTTP server to attach the WebSocket server on.  options.ws : An existing WebSocket server to be re-used.   \n                 \n                    \n         \n            \n         \n             Express \n         \n    \n         \n             http.createServer \n         \n    \n         \n             WebSocket.Server \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   express   from   express ;  import   {   Server   }   from   colyseus ;  const   app   =   new   express ();  const   gameServer   =   new   Server ();  gameServer . attach ({   server :   app   });  \n\n         \n    \n         \n             import   *   as   http   from   http ;  import   {   Server   }   from   colyseus ;  const   httpServer   =   http . createServer ();  const   gameServer   =   new   Server ();  gameServer . attach ({   server :   httpServer   });  \n\n         \n    \n         \n             import   *   as   http   from   http ;  import   *   as   express   from   express ;  import   *   as   ws   from   ws ;  import   {   Server   }   from   colyseus ;  const   app   =   express ();  const   server   =   http . createServer ( app );  const   wss   =   new   WebSocket . Server ({ \n     // your custom WebSocket.Server setup.  });  const   gameServer   =   new   Server ();  gameServer . attach ({   ws :   wss   });", 
            "title": "attach (options: any)"
        }, 
        {
            "location": "/api-server/#listen-port-number", 
            "text": "Binds the WebSocket server into the specified port.", 
            "title": "listen (port: number)"
        }, 
        {
            "location": "/api-server/#onshutdown-callback-function", 
            "text": "Register a callback that should be called before the process shut down. See  graceful shutdown  for more details.", 
            "title": "onShutdown (callback: Function)"
        }, 
        {
            "location": "/api-server/#clusterserver", 
            "text": "Recommended for production environment.   The  ClusterServer  has the same functionality of  Server , with some caveats. You'll need to use the  \"cluster\"  module by yourself and call its methods in the right node type.   See  Clustered environment  for more details.", 
            "title": "ClusterServer"
        }, 
        {
            "location": "/api-server/#fork-workers-number", 
            "text": "Specify the number of session workers to spawn. By default it uses the number of available CPUs.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   cluster   from   cluster ;  import   {   ClusterServer   }   from   colyseus ;  let   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n     gameServer . listen ( 8080 ); \n     gameServer . fork ( 4 );  }   else   { \n     // ...  }  \n\n         \n    \n         \n             const   cluster   =   require ( cluster );  const   ClusterServer   =   require ( colyseus ). ClusterServer ;  let   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n     gameServer . listen ( 8080 ); \n     gameServer . fork ( 4 );  }   else   { \n     // ...  }", 
            "title": "fork (workers?: number)"
        }, 
        {
            "location": "/api-client/", 
            "text": "Web-Socket Client\n\n\nThe \nclient\n instance present on:\n\n\n\n\nRoom#clients\n\n\nRoom#verifyClient()\n\n\nRoom#onJoin()\n\n\nRoom#onMessage()\n\n\nRoom#onLeave()\n\n\n\n\n\n\nNote\n\n\nThis is the raw WebSocket connection coming from the \nws\n package. There are more methods available which aren't encouraged to use along with Colyseus.\n\n\n\n\nMethods\n\n\nclose(code?: number)\n\n\nForce disconnection of the \nclient\n with the server.\n\n\n\n\nTip\n\n\nThis will trigger \nroom.onLeave\n event on the client-side.\n\n\n\n\nProperties\n\n\nid: string\n\n\nUnique id per client. When the same client connects with multiple browser tabs, the \nid\n will be the same for every connection.\n\n\nsessionId: string\n\n\nUnique id per session. Whilst you may have the same \nid\n for multiple sessions from the same client, the \nsessionId\n is always unique.", 
            "title": "Web-Socket Client"
        }, 
        {
            "location": "/api-client/#web-socket-client", 
            "text": "The  client  instance present on:   Room#clients  Room#verifyClient()  Room#onJoin()  Room#onMessage()  Room#onLeave()    Note  This is the raw WebSocket connection coming from the  ws  package. There are more methods available which aren't encouraged to use along with Colyseus.", 
            "title": "Web-Socket Client"
        }, 
        {
            "location": "/api-client/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/api-client/#closecode-number", 
            "text": "Force disconnection of the  client  with the server.   Tip  This will trigger  room.onLeave  event on the client-side.", 
            "title": "close(code?: number)"
        }, 
        {
            "location": "/api-client/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/api-client/#id-string", 
            "text": "Unique id per client. When the same client connects with multiple browser tabs, the  id  will be the same for every connection.", 
            "title": "id: string"
        }, 
        {
            "location": "/api-client/#sessionid-string", 
            "text": "Unique id per session. Whilst you may have the same  id  for multiple sessions from the same client, the  sessionId  is always unique.", 
            "title": "sessionId: string"
        }, 
        {
            "location": "/api-authentication/", 
            "text": "You may implement the \nverifyClient(client, options)\n method validate the authenticity of your clients. \n\n\nWhen requesting to join a room, that's the order of methods which will be called in your room handler:\n\n\n\n\nrequestJoin\n - should check if a room is available for new clients\n\n\nverifyClient (client, options)\n - should validate the client based on the options provided (i.e. auth token)\n\n\nonJoin (client, options)\n - should initialize the newly connected client into your room's state.\n\n\n\n\nFrom the client-side, you'd call the \njoin\n method with a token from some authentication service (i. e. Facebook):\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\njoin\n(\nworld\n,\n \n{\n\n  \naccessToken\n:\n \nyourFacebookAccessToken\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nJoin\n(\nworld\n,\n \nnew\n \n{\n\n  \naccessToken\n \n=\n \nyourFacebookAccessToken\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nThe \nverifyClient\n method in your room handler should return \ntrue\n only if the access token is valid.\n\n\nSynchronous usage\n\n\nYou can immediatelly return a \nboolean\n value.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nverifyClient\n \n(\nclient\n,\n \noptions\n)\n:\n \nboolean\n \n{\n\n    \nreturn\n \n(\noptions\n.\npassword\n \n===\n \nsecret\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAsynchronous usage\n\n\nYou can return a \nPromise\n, and perform some asynchronous task to validate the client.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nverifyClient\n \n(\nclient\n,\n \noptions\n)\n:\n \nPromise\n \n{\n\n    \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n      \nvalidateToken\n(\noptions\n.\naccessToken\n,\n \n(\nerr\n,\n \nsuccess\n)\n \n=\n \n{\n\n        \nif\n \n(\n!\nerr\n)\n \n{\n \n          \nresolve\n();\n\n        \n}\n \nelse\n \n{\n\n          \nreject\n(\nerr\n);\n\n        \n}\n\n      \n});\n\n    \n});\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAlternatively, you can use \nasync\n / \nawait\n, which will return a \nPromise\n under the hood.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nasync\n \nverifyClient\n \n(\nclient\n,\n \noptions\n)\n \n{\n\n    \nconst\n \nuserData\n \n=\n \nawait\n \nvalidateToken\n(\noptions\n.\naccessToken\n);\n\n    \nreturn\n \n(\nuserData\n)\n \n?\n \ntrue\n \n:\n \nfalse\n;\n\n  \n}\n\n\n}", 
            "title": "Authentication"
        }, 
        {
            "location": "/api-authentication/#synchronous-usage", 
            "text": "You can immediatelly return a  boolean  value.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   verifyClient   ( client ,   options ) :   boolean   { \n     return   ( options . password   ===   secret ); \n   }  }", 
            "title": "Synchronous usage"
        }, 
        {
            "location": "/api-authentication/#asynchronous-usage", 
            "text": "You can return a  Promise , and perform some asynchronous task to validate the client.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   verifyClient   ( client ,   options ) :   Promise   { \n     return   new   Promise (( resolve ,   reject )   =   { \n       validateToken ( options . accessToken ,   ( err ,   success )   =   { \n         if   ( ! err )   {  \n           resolve (); \n         }   else   { \n           reject ( err ); \n         } \n       }); \n     }); \n   }  }   Alternatively, you can use  async  /  await , which will return a  Promise  under the hood.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   async   verifyClient   ( client ,   options )   { \n     const   userData   =   await   validateToken ( options . accessToken ); \n     return   ( userData )   ?   true   :   false ; \n   }  }", 
            "title": "Asynchronous usage"
        }, 
        {
            "location": "/api-graceful-shutdown/", 
            "text": "Graceful Shutdown\n\n\nColyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself:\n\n\n\n\nDisconnect all connected clients asynchronously (\nRoom#onLeave\n)\n\n\nDispose all spawned rooms asynchronously (\nRoom#onDispose\n)\n\n\nPerform optional asynchronous callback before shutting down the process (\nServer#onShutdown\n / \nClusterServer#onShutdown\n)\n\n\n\n\nIf you're performing async tasks on \nonLeave\n / \nonDispose\n, you should return a \nPromise\n, and resolve it when the task is ready. The same applies to \nonShutdown(callback)\n.\n\n\nReturning a \nPromise\n\n\nBy returning a \nPromise\n, the server will wait for them to be completed before killing the worker process.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonLeave\n \n(\nclient\n)\n \n{\n\n        \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n            \ndoDatabaseOperation\n((\nerr\n,\n \ndata\n)\n \n=\n \n{\n\n                \nif\n \n(\nerr\n)\n \n{\n\n                    \nreject\n(\nerr\n);\n\n                \n}\n \nelse\n \n{\n\n                    \nresolve\n(\ndata\n);\n\n                \n}\n\n            \n});\n\n        \n});\n\n    \n}\n\n\n    \nonDispose\n \n()\n \n{\n\n        \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n            \ndoDatabaseOperation\n((\nerr\n,\n \ndata\n)\n \n=\n \n{\n\n                \nif\n \n(\nerr\n)\n \n{\n\n                    \nreject\n(\nerr\n);\n\n                \n}\n \nelse\n \n{\n\n                    \nresolve\n(\ndata\n);\n\n                \n}\n\n            \n});\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nUsing \nasync\n\n\nThe \nasync\n keyword will makes your function return a \nPromise\n under the hood. \nRead more about Async / Await\n.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nasync\n \nonLeave\n \n(\nclient\n)\n \n{\n\n        \nawait\n \ndoDatabaseOperation\n(\nclient\n);\n\n    \n}\n\n\n    \nasync\n \nonDispose\n \n()\n \n{\n\n        \nawait\n \nremoveRoomFromDatabase\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nProcess shutdown callback\n\n\nYou can also listen for process shutdown by setting a \nonShutdown\n callback.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nServer\n\n        \n\n    \n        \n\n            \nCluster Server\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nlet\n \nserver\n \n=\n \nnew\n \nServer\n();\n\n\n\nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\nmaster process is being shut down!\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n*\n \nas\n \ncluster\n \nfrom\n \ncluster\n;\n\n\nimport\n \n{\n \nClusterServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nlet\n \nserver\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n    \nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n        \nconsole\n.\nlog\n(\nmaster process is being shut down!\n);\n\n    \n});\n\n\n\n}\n \nelse\n \n{\n\n    \nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n        \nconsole\n.\nlog\n(\nworker process is being shut down!\n);\n\n    \n});\n\n\n}", 
            "title": "Graceful shutdown"
        }, 
        {
            "location": "/api-graceful-shutdown/#graceful-shutdown", 
            "text": "Colyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself:   Disconnect all connected clients asynchronously ( Room#onLeave )  Dispose all spawned rooms asynchronously ( Room#onDispose )  Perform optional asynchronous callback before shutting down the process ( Server#onShutdown  /  ClusterServer#onShutdown )   If you're performing async tasks on  onLeave  /  onDispose , you should return a  Promise , and resolve it when the task is ready. The same applies to  onShutdown(callback) .", 
            "title": "Graceful Shutdown"
        }, 
        {
            "location": "/api-graceful-shutdown/#returning-a-promise", 
            "text": "By returning a  Promise , the server will wait for them to be completed before killing the worker process.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n     onLeave   ( client )   { \n         return   new   Promise (( resolve ,   reject )   =   { \n             doDatabaseOperation (( err ,   data )   =   { \n                 if   ( err )   { \n                     reject ( err ); \n                 }   else   { \n                     resolve ( data ); \n                 } \n             }); \n         }); \n     } \n\n     onDispose   ()   { \n         return   new   Promise (( resolve ,   reject )   =   { \n             doDatabaseOperation (( err ,   data )   =   { \n                 if   ( err )   { \n                     reject ( err ); \n                 }   else   { \n                     resolve ( data ); \n                 } \n             }); \n         }); \n     }  }", 
            "title": "Returning a Promise"
        }, 
        {
            "location": "/api-graceful-shutdown/#using-async", 
            "text": "The  async  keyword will makes your function return a  Promise  under the hood.  Read more about Async / Await .  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n     async   onLeave   ( client )   { \n         await   doDatabaseOperation ( client ); \n     } \n\n     async   onDispose   ()   { \n         await   removeRoomFromDatabase (); \n     }  }", 
            "title": "Using async"
        }, 
        {
            "location": "/api-graceful-shutdown/#process-shutdown-callback", 
            "text": "You can also listen for process shutdown by setting a  onShutdown  callback.  \n                 \n                    \n         \n            \n         \n             Server \n         \n    \n         \n             Cluster Server \n         \n    \n         \n    \n         \n            \n         \n             import   {   Server   }   from   colyseus ;  let   server   =   new   Server ();  server . onShutdown ( function   ()   { \n     console . log ( master process is being shut down! );  });  \n\n         \n    \n         \n             import   *   as   cluster   from   cluster ;  import   {   ClusterServer   }   from   colyseus ;  let   server   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n     server . onShutdown ( function   ()   { \n         console . log ( master process is being shut down! ); \n     });  }   else   { \n     server . onShutdown ( function   ()   { \n         console . log ( worker process is being shut down! ); \n     });  }", 
            "title": "Process shutdown callback"
        }, 
        {
            "location": "/api-debugging/", 
            "text": "Debug messages\n\n\nInspector (\n--inspect\n flag)\n\n\n\n\nDebug messages\n\n\nThe server provides some debug messages that you can enable individually per category, by setting the \nDEBUG\n environment variable.\n\n\nTo enable all logs, you can run your server using:\n\n\nDEBUG=colyseus:* node server.js\n\n\n\n\n\nSee below all available debug categories with sample outputs.\n\n\ncolyseus:patch\n\n\nLogs the number of bytes and interval between patches broadcasted to all clients.\n\n\ncolyseus:patch \nchat\n (roomId: \nryWiL5rLTZ\n) is sending 28 bytes: +57ms\n\n\n\n\n\ncolyseus:patch:data\n\n\nDisplays a human-readable version of the data broadcasted to all clients.\n\n\ncolyseus:patch:data [ { op: \nreplace\n, path: \n/players/BygiLqrLpZ/x\n, value: 5 } ] +56ms\n\n\n\n\n\ncolyseus:cluster\n\n\nLogs when worker processes are spawned and re-spawned. \n\n\ncolyseus:cluster master spawned with pid 77216 +0ms\ncolyseus:cluster matchmaking spawned with pid 77217 +8ms\ncolyseus:cluster fork spawned with pid 77218 +7ms\ncolyseus:cluster fork spawned with pid 77219 +3ms\ncolyseus:cluster fork spawned with pid 77220 +3ms\ncolyseus:cluster fork spawned with pid 77221 +17ms\n\n\n\n\n\ncolyseus:matchmaking\n\n\nLogs the messages sent back and forth from master node to worker processes. You'll see them only if using \nClusterServer\n.\n\n\ncolyseus:matchmaking requesting CREATE_ROOM +54s\ncolyseus:matchmaking spawning \nchat\n on worker 77218 +52s\ncolyseus:matchmaking disposing \nchat\n on worker 77218 +2s\n\n\n\n\n\nInspector\n\n\nTo be able to use the \nbuilt-in inspector from Node.js\n\nyou'll need to use the \nServer\n class, which doesn't use inter-process communication. \n\n\nFor production, \nClusterServer\n is recommended, though.", 
            "title": "Debugging"
        }, 
        {
            "location": "/api-debugging/#debug-messages", 
            "text": "The server provides some debug messages that you can enable individually per category, by setting the  DEBUG  environment variable.  To enable all logs, you can run your server using:  DEBUG=colyseus:* node server.js  See below all available debug categories with sample outputs.", 
            "title": "Debug messages"
        }, 
        {
            "location": "/api-debugging/#colyseuspatch", 
            "text": "Logs the number of bytes and interval between patches broadcasted to all clients.  colyseus:patch  chat  (roomId:  ryWiL5rLTZ ) is sending 28 bytes: +57ms", 
            "title": "colyseus:patch"
        }, 
        {
            "location": "/api-debugging/#colyseuspatchdata", 
            "text": "Displays a human-readable version of the data broadcasted to all clients.  colyseus:patch:data [ { op:  replace , path:  /players/BygiLqrLpZ/x , value: 5 } ] +56ms", 
            "title": "colyseus:patch:data"
        }, 
        {
            "location": "/api-debugging/#colyseuscluster", 
            "text": "Logs when worker processes are spawned and re-spawned.   colyseus:cluster master spawned with pid 77216 +0ms\ncolyseus:cluster matchmaking spawned with pid 77217 +8ms\ncolyseus:cluster fork spawned with pid 77218 +7ms\ncolyseus:cluster fork spawned with pid 77219 +3ms\ncolyseus:cluster fork spawned with pid 77220 +3ms\ncolyseus:cluster fork spawned with pid 77221 +17ms", 
            "title": "colyseus:cluster"
        }, 
        {
            "location": "/api-debugging/#colyseusmatchmaking", 
            "text": "Logs the messages sent back and forth from master node to worker processes. You'll see them only if using  ClusterServer .  colyseus:matchmaking requesting CREATE_ROOM +54s\ncolyseus:matchmaking spawning  chat  on worker 77218 +52s\ncolyseus:matchmaking disposing  chat  on worker 77218 +2s", 
            "title": "colyseus:matchmaking"
        }, 
        {
            "location": "/api-debugging/#inspector", 
            "text": "To be able to use the  built-in inspector from Node.js \nyou'll need to use the  Server  class, which doesn't use inter-process communication.   For production,  ClusterServer  is recommended, though.", 
            "title": "Inspector"
        }, 
        {
            "location": "/client-overview/", 
            "text": "Overview\n\n\nColyseus currently have clients for the platforms:\n\n\n\n\nHTML5\n\n\nUnity3D\n\n\n\n\nNeed a client for another platform? Share your interest on the \ndiscussion board\n!\n\n\nConnecting to the Server\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \nColyseus\n \nfrom\n \ncolyseus.js\n;\n\n\n// ...\n\n\n\nlet\n \nclient\n \n=\n \nnew\n \nColyseus\n.\nClient\n(\nws://localhost:2657\n);\n\n\n\n\n        \n\n    \n        \n\n            \nusing\n \nColyseus\n;\n\n\n// ...\n\n\n\nClient\n \nclient\n \n=\n \nnew\n \nClient\n(\nws://localhost:2657\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nMethods\n\n\njoin (roomName: string, options: any)\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nlet\n \nroom\n \n=\n \nclient\n.\njoin\n(\nbattle\n);\n\n\n\n\n        \n\n    \n        \n\n            \nRoom\n \nroom\n \n=\n \nclient\n.\nJoin\n(\nbattle\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nEvents\n\n\nonOpen\n\n\nThis event is triggered when the connection is accepted by the server.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\nonOpen\n.\nadd\n(\nfunction\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nconnection is now open\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nOnOpen\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nconnection is now open\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonClose\n\n\nThis event is triggered when the connection is closed.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\nonClose\n.\nadd\n(\nfunction\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nconnection has been closed\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nOnClose\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nconnection has been closed\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonError\n\n\nThis event is triggered when some error occurs in the server.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\nonError\n.\nadd\n(\nfunction\n(\nerr\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nsomething wrong happened\n,\n \nerr\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nOnError\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nsomething wrong happened\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n\n\n\n\n\n\nProperties\n\n\nid: string\n\n\nUnique identifier for the client.\n\n\n\n\nNote\n\n\nThe same client id can connect into the same room handler when joining from multiple browser tabs.", 
            "title": "Overview"
        }, 
        {
            "location": "/client-overview/#overview", 
            "text": "Colyseus currently have clients for the platforms:   HTML5  Unity3D   Need a client for another platform? Share your interest on the  discussion board !", 
            "title": "Overview"
        }, 
        {
            "location": "/client-overview/#connecting-to-the-server", 
            "text": "TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   Colyseus   from   colyseus.js ;  // ...  let   client   =   new   Colyseus . Client ( ws://localhost:2657 );  \n\n         \n    \n         \n             using   Colyseus ;  // ...  Client   client   =   new   Client ( ws://localhost:2657 );", 
            "title": "Connecting to the Server"
        }, 
        {
            "location": "/client-overview/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/client-overview/#join-roomname-string-options-any", 
            "text": "TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             let   room   =   client . join ( battle );  \n\n         \n    \n         \n             Room   room   =   client . Join ( battle );", 
            "title": "join (roomName: string, options: any)"
        }, 
        {
            "location": "/client-overview/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/client-overview/#onopen", 
            "text": "This event is triggered when the connection is accepted by the server.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             client . onOpen . add ( function ()   { \n   console . log ( connection is now open );  });  \n\n         \n    \n         \n             client . OnOpen   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( connection is now open );  }", 
            "title": "onOpen"
        }, 
        {
            "location": "/client-overview/#onclose", 
            "text": "This event is triggered when the connection is closed.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             client . onClose . add ( function ()   { \n   console . log ( connection has been closed );  });  \n\n         \n    \n         \n             client . OnClose   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( connection has been closed );  }", 
            "title": "onClose"
        }, 
        {
            "location": "/client-overview/#onerror", 
            "text": "This event is triggered when some error occurs in the server.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             client . onError . add ( function ( err )   { \n   console . log ( something wrong happened ,   err );  });  \n\n         \n    \n         \n             client . OnError   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( something wrong happened );  }", 
            "title": "onError"
        }, 
        {
            "location": "/client-overview/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/client-overview/#id-string", 
            "text": "Unique identifier for the client.   Note  The same client id can connect into the same room handler when joining from multiple browser tabs.", 
            "title": "id: string"
        }, 
        {
            "location": "/client-room/", 
            "text": "Client-side Room API\n\n\nMethods\n\n\nlisten (path: string, callback: Function)\n\n\nListen to room state changes from the room handler.\n\n\nUse this method to synchronize the room state from the server with the clients.\n\n\nExamples\n\n\nListening to map data structures\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nDataChange\n \n}\n \nfrom\n \ncolyseus.js\n;\n\n\n// ...\n\n\n\nroom\n.\nlisten\n(\nplayers/:id\n,\n \n(\nchange\n: \nDataChange\n)\n \n=\n \n{\n\n  \nif\n \n(\nchange\n.\noperation\n \n===\n \nadd\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nnew player added to the state\n);\n\n    \nconsole\n.\nlog\n(\nplayer id:\n,\n \nchange\n.\npath\n.\nid\n);\n\n    \nconsole\n.\nlog\n(\nplayer data:\n,\n \nchange\n.\nvalue\n);\n\n\n  \n}\n \nelse\n \nif\n \n(\nchange\n.\noperation\n \n===\n \nremove\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nplayer has been removed from the state\n);\n\n    \nconsole\n.\nlog\n(\nplayer id:\n,\n \nchange\n.\npath\n.\nid\n);\n\n  \n}\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nusing\n \nColyseus\n;\n\n\n// ...\n\n\n\nroom\n.\nListen\n(\nplayers/:id\n,\n \nOnPlayerChange\n);\n\n\n\nvoid\n \nOnPlayerChange\n \n(\nDataChange\n \nchange\n)\n\n\n{\n\n  \nif\n \n(\nchange\n.\noperation\n \n==\n \nadd\n)\n \n{\n\n    \nDebug\n.\nLog\n \n(\nnew player added to the state\n);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\nvalue\n);\n\n\n  \n}\n \nelse\n \nif\n \n(\nchange\n.\noperation\n \n==\n \nremove\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nplayer has been removed from the state\n);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n\n  \n}\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nListening to attribute changes of deep data structures\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nDataChange\n \n}\n \nfrom\n \ncolyseus.js\n;\n\n\n// ...\n\n\n\nroom\n.\nlisten\n(\nplayers/:id/:attribute\n,\n \n(\nchange\n: \nDataChange\n)\n \n=\n \n{\n\n  \nconsole\n.\nlog\n(\nchange\n.\noperation\n);\n \n// =\n \nadd\n | \nremove\n | \nreplace\n\n  \nconsole\n.\nlog\n(\nchange\n.\npath\n.\nattribute\n,\n \nhas been changed\n);\n\n  \nconsole\n.\nlog\n(\nchange\n.\npath\n.\nid\n);\n\n  \nconsole\n.\nlog\n(\nchange\n.\nvalue\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nusing\n \nColyseus\n;\n\n\n// ...\n\n\n\nroom\n.\nListen\n(\nplayers/:id/:attribute\n,\n \nOnPlayerAttributeChange\n);\n\n\n\nvoid\n \nOnPlayerAttributeChange\n \n(\nDataChange\n \nchange\n)\n\n\n{\n\n  \nDebug\n.\nLog\n \n(\nchange\n.\noperation\n);\n \n// =\n \nadd\n | \nremove\n | \nreplace\n\n  \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nattribute\n]\n \n+\n \nhas been changed\n);\n\n  \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n\n  \nDebug\n.\nLog\n \n(\nchange\n.\nvalue\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n\n\nTip\n\n\nSee \nState synchronization\n for more examples on how to use the \nlisten\n method.\n\n\n\n\nsend (data)\n\n\nSend message to the room handler.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nsend\n({\n \nmove\n:\n \nleft\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nSend\n(\nnew\n \n{\n \nmove\n \n=\n \nleft\n \n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nUse \nRoom#onMessage()\n from the server-side to read the message.\n\n\nleave ()\n\n\nDisconnect from the room.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nleave\n();\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nLeave\n();\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n\n\nTip\n\n\nUse \nRoom#onLeave()\n to handle the disconnection from the server-side.\n\n\n\n\nremoveAllListeners()\n\n\nRemove all event and data listeners.\n\n\nProperties\n\n\nid: string\n\n\nThe unique idenfitier of the room. You can share this id with other clients in\norder to allow them to connect directly to this room.\n\n\n// get `roomId` from the query string\n\n\nlet\n \nroomId\n \n=\n \nlocation\n.\nhref\n.\nmatch\n(\n/roomId=([a-zA-Z0-9\\-_]+)/\n)[\n1\n];\n\n\n\n// connect the client directly into a specific room id\n\n\nlet\n \nroom\n \n=\n \nclient\n.\njoin\n(\nroomId\n);\n\n\n\n\n\n\n\n\nWarning\n\n\nIf you're looking for the unique identifier of the client, use \nclient.id\n instead.\n\n\n\n\nsessionId: string\n\n\nUnique session identifier.\n\n\nThis property matches the \nclient.sessionId\n from the server-side.\n\n\nname: string\n\n\nName of the room handler. Ex: \n\"battle\"\n.\n\n\nEvents\n\n\nonUpdate\n\n\nThis event is triggered when the server updates its state.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonUpdate\n.\naddOnce\n(\nfunction\n(\nstate\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nthis is the first room state!\n,\n \nstate\n);\n\n\n});\n\n\n\nroom\n.\nonUpdate\n.\nadd\n(\nfunction\n(\nstate\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nthe room state has been updated:\n,\n \nstate\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnUpdate\n \n+=\n \n(\nobject\n \nsender\n,\n \nRoomUpdateEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nif\n \n(\ne\n.\nisFirstState\n)\n \n{\n\n    \nDebug\n.\nLog\n \n(\nthis is the first room state!\n);\n\n  \n}\n\n\n  \nDebug\n.\nLog\n \n(\nthe room state has been updated\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonData\n\n\nThis event is triggered when the server sends data directly to the client.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonData\n.\nadd\n(\nfunction\n(\ndata\n)\n \n{\n\n  \nconsole\n.\nlog\n(\nserver just sent this message:\n);\n\n  \nconsole\n.\nlog\n(\ndata\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnData\n \n+=\n \n(\nobject\n \nsender\n,\n \nMessageEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nserver just sent this message:\n);\n\n  \nDebug\n.\nLog\n(\ne\n.\ndata\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\n\n\nTip\n\n\nTo send data from the server directly to the clients you'll need to use\neither \nroom.send()\n or\n\nroom.broadcast()\n\n\n\n\nonJoin\n\n\nThis event is triggered when the client successfuly joins the room.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonJoin\n.\nadd\n(\nfunction\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nclient joined successfully\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnJoin\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nclient joined successfully\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonLeave\n\n\nThis event is triggered when the client leave the room.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonLeave\n.\nadd\n(\nfunction\n()\n \n{\n\n  \nconsole\n.\nlog\n(\nclient left the room\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnLeave\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\nclient left the room\n);\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nonError\n\n\nThis event is triggered when some error occurs in the room handler.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nonError\n.\nadd\n(\nfunction\n(\nerr\n)\n \n{\n\n  \nconsole\n.\nlog\n(\noops, error ocurred:\n);\n\n  \nconsole\n.\nlog\n(\nerr\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nOnError\n \n+=\n \n(\nobject\n \nsender\n,\n \nEventArgs\n \ne\n)\n \n=\n \n{\n\n  \nDebug\n.\nLog\n \n(\noops, error ocurred:\n);\n\n  \nDebug\n.\nLog\n(\ne\n);\n\n\n}", 
            "title": "Room"
        }, 
        {
            "location": "/client-room/#client-side-room-api", 
            "text": "", 
            "title": "Client-side Room API"
        }, 
        {
            "location": "/client-room/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/client-room/#listen-path-string-callback-function", 
            "text": "Listen to room state changes from the room handler.  Use this method to synchronize the room state from the server with the clients.", 
            "title": "listen (path: string, callback: Function)"
        }, 
        {
            "location": "/client-room/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/client-room/#listening-to-map-data-structures", 
            "text": "TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             import   {   DataChange   }   from   colyseus.js ;  // ...  room . listen ( players/:id ,   ( change :  DataChange )   =   { \n   if   ( change . operation   ===   add )   { \n     console . log ( new player added to the state ); \n     console . log ( player id: ,   change . path . id ); \n     console . log ( player data: ,   change . value ); \n\n   }   else   if   ( change . operation   ===   remove )   { \n     console . log ( player has been removed from the state ); \n     console . log ( player id: ,   change . path . id ); \n   }  });  \n\n         \n    \n         \n             using   Colyseus ;  // ...  room . Listen ( players/:id ,   OnPlayerChange );  void   OnPlayerChange   ( DataChange   change )  { \n   if   ( change . operation   ==   add )   { \n     Debug . Log   ( new player added to the state ); \n     Debug . Log   ( change . path [ id ]); \n     Debug . Log   ( change . value ); \n\n   }   else   if   ( change . operation   ==   remove )   { \n     console . log ( player has been removed from the state ); \n     Debug . Log   ( change . path [ id ]); \n   }  });", 
            "title": "Listening to map data structures"
        }, 
        {
            "location": "/client-room/#listening-to-attribute-changes-of-deep-data-structures", 
            "text": "TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             import   {   DataChange   }   from   colyseus.js ;  // ...  room . listen ( players/:id/:attribute ,   ( change :  DataChange )   =   { \n   console . log ( change . operation );   // =   add  |  remove  |  replace \n   console . log ( change . path . attribute ,   has been changed ); \n   console . log ( change . path . id ); \n   console . log ( change . value );  });  \n\n         \n    \n         \n             using   Colyseus ;  // ...  room . Listen ( players/:id/:attribute ,   OnPlayerAttributeChange );  void   OnPlayerAttributeChange   ( DataChange   change )  { \n   Debug . Log   ( change . operation );   // =   add  |  remove  |  replace \n   Debug . Log   ( change . path [ attribute ]   +   has been changed ); \n   Debug . Log   ( change . path [ id ]); \n   Debug . Log   ( change . value );  });  \n\n         \n    \n         \n    \n                 \n                       Tip  See  State synchronization  for more examples on how to use the  listen  method.", 
            "title": "Listening to attribute changes of deep data structures"
        }, 
        {
            "location": "/client-room/#send-data", 
            "text": "Send message to the room handler.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             room . send ({   move :   left   });  \n\n         \n    \n         \n             room . Send ( new   {   move   =   left   });  \n\n         \n    \n         \n    \n                 \n                      Use  Room#onMessage()  from the server-side to read the message.", 
            "title": "send (data)"
        }, 
        {
            "location": "/client-room/#leave", 
            "text": "Disconnect from the room.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             room . leave ();  \n\n         \n    \n         \n             room . Leave ();  \n\n         \n    \n         \n    \n                 \n                       Tip  Use  Room#onLeave()  to handle the disconnection from the server-side.", 
            "title": "leave ()"
        }, 
        {
            "location": "/client-room/#removealllisteners", 
            "text": "Remove all event and data listeners.", 
            "title": "removeAllListeners()"
        }, 
        {
            "location": "/client-room/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/client-room/#id-string", 
            "text": "The unique idenfitier of the room. You can share this id with other clients in\norder to allow them to connect directly to this room.  // get `roomId` from the query string  let   roomId   =   location . href . match ( /roomId=([a-zA-Z0-9\\-_]+)/ )[ 1 ];  // connect the client directly into a specific room id  let   room   =   client . join ( roomId );    Warning  If you're looking for the unique identifier of the client, use  client.id  instead.", 
            "title": "id: string"
        }, 
        {
            "location": "/client-room/#sessionid-string", 
            "text": "Unique session identifier.  This property matches the  client.sessionId  from the server-side.", 
            "title": "sessionId: string"
        }, 
        {
            "location": "/client-room/#name-string", 
            "text": "Name of the room handler. Ex:  \"battle\" .", 
            "title": "name: string"
        }, 
        {
            "location": "/client-room/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/client-room/#onupdate", 
            "text": "This event is triggered when the server updates its state.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             room . onUpdate . addOnce ( function ( state )   { \n   console . log ( this is the first room state! ,   state );  });  room . onUpdate . add ( function ( state )   { \n   console . log ( the room state has been updated: ,   state );  });  \n\n         \n    \n         \n             room . OnUpdate   +=   ( object   sender ,   RoomUpdateEventArgs   e )   =   { \n   if   ( e . isFirstState )   { \n     Debug . Log   ( this is the first room state! ); \n   } \n\n   Debug . Log   ( the room state has been updated );  }", 
            "title": "onUpdate"
        }, 
        {
            "location": "/client-room/#ondata", 
            "text": "This event is triggered when the server sends data directly to the client.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             room . onData . add ( function ( data )   { \n   console . log ( server just sent this message: ); \n   console . log ( data );  });  \n\n         \n    \n         \n             room . OnData   +=   ( object   sender ,   MessageEventArgs   e )   =   { \n   Debug . Log   ( server just sent this message: ); \n   Debug . Log ( e . data );  }  \n\n         \n    \n         \n    \n                 \n                       Tip  To send data from the server directly to the clients you'll need to use\neither  room.send()  or room.broadcast()", 
            "title": "onData"
        }, 
        {
            "location": "/client-room/#onjoin", 
            "text": "This event is triggered when the client successfuly joins the room.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             room . onJoin . add ( function ()   { \n   console . log ( client joined successfully );  });  \n\n         \n    \n         \n             room . OnJoin   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( client joined successfully );  }", 
            "title": "onJoin"
        }, 
        {
            "location": "/client-room/#onleave", 
            "text": "This event is triggered when the client leave the room.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             room . onLeave . add ( function ()   { \n   console . log ( client left the room );  });  \n\n         \n    \n         \n             room . OnLeave   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( client left the room );  }", 
            "title": "onLeave"
        }, 
        {
            "location": "/client-room/#onerror", 
            "text": "This event is triggered when some error occurs in the room handler.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             C# \n         \n    \n         \n    \n         \n            \n         \n             room . onError . add ( function ( err )   { \n   console . log ( oops, error ocurred: ); \n   console . log ( err );  });  \n\n         \n    \n         \n             room . OnError   +=   ( object   sender ,   EventArgs   e )   =   { \n   Debug . Log   ( oops, error ocurred: ); \n   Debug . Log ( e );  }", 
            "title": "onError"
        }, 
        {
            "location": "/client-state-synchronization/", 
            "text": "Whenever the \nstate mutates\n in the server-side, you can listen to particular variable changes in the client-side.\n\n\nThe \nRoom\n instance in the client-side uses \ndelta-listener\n to allow you to trigger callbacks for particular mutations.\n\n\nExample\n\n\nLet's say you have a list of entities and its positions in your server-side:\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonInit\n \n()\n \n{\n\n        \nthis\n.\nsetState\n({\n\n            \nentities\n:\n \n{\n\n                \nf98h3f\n:\n \n{\n \nx\n:\n \n0\n,\n \ny\n:\n \n0\n,\n \nhp\n:\n \n10\n \n},\n\n                \n24jgd3\n:\n \n{\n \nx\n:\n \n100\n,\n \ny\n:\n \n0\n,\n \nhp\n:\n \n6\n \n}\n\n            \n}\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn the client-side, you want to listen for mutations in the attributes of these entities. Before being able to catch them, we need to mutate them. The mutation can occur during your simulation interval, or by actions taken by connected clients (during \nonMessage\n in the server-side).\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonInit\n \n()\n \n{\n\n        \n// this.setState(...) see above\n\n        \nthis\n.\nsetSimulationInterval\n(()\n \n=\n \nthis\n.\nupdate\n());\n\n    \n}\n\n\n    \nupdate\n \n()\n \n{\n\n        \nfor\n \n(\nlet\n \nentityId\n \nin\n \nthis\n.\nstate\n.\nentities\n)\n \n{\n\n            \n// simple and naive gravity\n\n            \nthis\n.\nstate\n.\nentities\n[\nentityId\n].\ny\n \n+=\n \n1\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow that we have the mutations in place, we can listen to them in the client-side. The callback will be called for each attribute, of each entity.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nlisten\n(\nentities/:id/:attribute\n,\n \n(\nchange\n)\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\nchange\n.\noperation\n);\n \n// =\n \nreplace\n (can be \nadd\n, \nremove\n or \nreplace\n)\n\n    \nconsole\n.\nlog\n(\nchange\n.\npath\n[\nid\n]);\n \n// =\n \nf98h3f\n\n    \nconsole\n.\nlog\n(\nchange\n.\npath\n[\nattribute\n]);\n \n// =\n \ny\n\n    \nconsole\n.\nlog\n(\nchange\n.\nvalue\n);\n \n// =\n 1\n\n\n})\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nListen\n(\nentities/:id/:attribute\n,\n \nOnAttributeChange\n);\n\n\n\nvoid\n \nOnAttributeChange\n \n(\nDataChange\n \nchange\n)\n\n\n{\n\n    \nDebug\n.\nLog\n \n(\nOnAttributeChange\n);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\noperation\n);\n \n// =\n \nreplace\n (can be \nadd\n, \nremove\n or \nreplace\n)\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n \n// =\n \nf98h3f\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nattribute\n]);\n \n// =\n \ny\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\nvalue\n);\n \n// =\n 1\n\n\n})", 
            "title": "State synchronization"
        }, 
        {
            "location": "/deployment/", 
            "text": "Deploying on Heroku\n\n\nDeploying on Zeit Now\n\n\nDeploying on Nginx (recommended)\n\n\n\n\nHeroku\n\n\nYou can deploy the \ncolyseus-examples\n project on Heroku by hitting this button: \n\n\n\n\nNote:\n You can't use the \nClusterServer\n under Heroku's free tier. Only \nServer\n works on free tier, which doesn't use multiple processes.\n\n\nZeit Now\n\n\nYou can deploy the \ncolyseus-examples\n project on Zeit Now by hitting this button: \n\n\n\n\nNote:\n You can't use the \nClusterServer\n under Zeit Now's free tier. Only \nServer\n works on free tier, which doesn't use multiple processes.\n\n\nNginx (recommended)\n\n\nIt's recommended to use \nforever\n and \nnginx\n in your production environment.\n\n\nForever\n\n\nInstall \nforever\n in your environment.\n\n\nnpm install -g forever\n\n\n\n\n\nThen start your game server using it:\n\n\nforever your-server.js\n\n\n\n\n\nNginx configuration\n\n\nserver {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \nupgrade\n;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}\n\n\n\n\n\nNginx configuration with SSL\n\n\nIt's recommended to acquire your certificate from \nLetsEncrypt\n.\n\n\nserver {\n    listen 80;\n    listen 443 ssl;\n    server_name yourdomain.com;\n\n    ssl_certificate /path/to/your/cert.crt;\n    ssl_certificate_key /path/to/your/cert.key;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \nupgrade\n;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Deployment"
        }, 
        {
            "location": "/deployment/#heroku", 
            "text": "You can deploy the  colyseus-examples  project on Heroku by hitting this button:    Note:  You can't use the  ClusterServer  under Heroku's free tier. Only  Server  works on free tier, which doesn't use multiple processes.", 
            "title": "Heroku"
        }, 
        {
            "location": "/deployment/#zeit-now", 
            "text": "You can deploy the  colyseus-examples  project on Zeit Now by hitting this button:    Note:  You can't use the  ClusterServer  under Zeit Now's free tier. Only  Server  works on free tier, which doesn't use multiple processes.", 
            "title": "Zeit Now"
        }, 
        {
            "location": "/deployment/#nginx-recommended", 
            "text": "It's recommended to use  forever  and  nginx  in your production environment.", 
            "title": "Nginx (recommended)"
        }, 
        {
            "location": "/deployment/#forever", 
            "text": "Install  forever  in your environment.  npm install -g forever  Then start your game server using it:  forever your-server.js", 
            "title": "Forever"
        }, 
        {
            "location": "/deployment/#nginx-configuration", 
            "text": "server {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection  upgrade ;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Nginx configuration"
        }, 
        {
            "location": "/deployment/#nginx-configuration-with-ssl", 
            "text": "It's recommended to acquire your certificate from  LetsEncrypt .  server {\n    listen 80;\n    listen 443 ssl;\n    server_name yourdomain.com;\n\n    ssl_certificate /path/to/your/cert.crt;\n    ssl_certificate_key /path/to/your/cert.key;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection  upgrade ;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Nginx configuration with SSL"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\nHow would I broadcast data from one client to others?\n\n\nYou usually don't do that. By using an authoritative game server, the clients generally send \nactions\n to the server, and the server \nmutates\n the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval.\n\n\nDo I need client-prediction in my game? Does Colyseus help me with this?\n\n\nColyseus does not provide any client-prediction solution out of the box. Games such as \nwilds.io\n and \ncrashracing.com\n do not use any form of client-prediction. \nlerp\ning user coordinates usually gives reasonable results.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#how-would-i-broadcast-data-from-one-client-to-others", 
            "text": "You usually don't do that. By using an authoritative game server, the clients generally send  actions  to the server, and the server  mutates  the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval.", 
            "title": "How would I broadcast data from one client to others?"
        }, 
        {
            "location": "/faq/#do-i-need-client-prediction-in-my-game-does-colyseus-help-me-with-this", 
            "text": "Colyseus does not provide any client-prediction solution out of the box. Games such as  wilds.io  and  crashracing.com  do not use any form of client-prediction.  lerp ing user coordinates usually gives reasonable results.", 
            "title": "Do I need client-prediction in my game? Does Colyseus help me with this?"
        }, 
        {
            "location": "/api-uws-support/", 
            "text": "\u00b5WS Support\n\n\nBy default, Colyseus uses the standard \nws\n package for the WebSocket server.\n\n\nYou can enable \nuws\n in your server by installing it as a dependency in your project.\n\n\nnpm install uws\n\n\n\n\n\nIt's that simple! Colyseus will automatically detect the dependency available in your \nnode_modules\n and use it instead of the default.", 
            "title": "\u00b5WS Support"
        }, 
        {
            "location": "/api-uws-support/#ws-support", 
            "text": "By default, Colyseus uses the standard  ws  package for the WebSocket server.  You can enable  uws  in your server by installing it as a dependency in your project.  npm install uws  It's that simple! Colyseus will automatically detect the dependency available in your  node_modules  and use it instead of the default.", 
            "title": "\u00b5WS Support"
        }, 
        {
            "location": "/roadmap/", 
            "text": "Overview:\n\n\n\n\nSupport vertical scalability (\n#43\n)\n - \u2714\n\n\nStandardize how to authenticate users in a secure way. (\n#49\n, suggested by \n@darkyen\n)\n - \u2714\n\n\nSupport for splitting and filtering views (\n#59\n, suggested by \n@darkyen\n and the whole \ngitter channel\n!)\n\n\nSupport serialization methods other than Fossil's Delta algorithm. (\n#58\n, suggested by \n@derwish-pro\n)\n\n\nPM2 support (\n#56\n)\n\n\nSupport horizontal scalability. (\n#57\n)\n\n\nSupport transport layers other than WebSocket. (\n#48\n, suggested by \n@darkyen\n)\n\n\n\n\nIn order to achieve these goals, it would be great to split Colyseus's internal parts as composable modules. Specially match-making, which is the most complex feature to deal with by having multiple servers/processes running.", 
            "title": "Roadmap"
        }, 
        {
            "location": "/roadmap/#overview", 
            "text": "Support vertical scalability ( #43 )  - \u2714  Standardize how to authenticate users in a secure way. ( #49 , suggested by  @darkyen )  - \u2714  Support for splitting and filtering views ( #59 , suggested by  @darkyen  and the whole  gitter channel !)  Support serialization methods other than Fossil's Delta algorithm. ( #58 , suggested by  @derwish-pro )  PM2 support ( #56 )  Support horizontal scalability. ( #57 )  Support transport layers other than WebSocket. ( #48 , suggested by  @darkyen )   In order to achieve these goals, it would be great to split Colyseus's internal parts as composable modules. Specially match-making, which is the most complex feature to deal with by having multiple servers/processes running.", 
            "title": "Overview:"
        }
    ]
}