{
    "docs": [
        {
            "location": "/", 
            "text": "Colyseus is a Authoritative Multiplayer Game Server for Node.js. It allows you to focus on your gameplay instead of bothering about networking.\n\n\nThe mission of this framework is to be the easiest solution for creating your\nown multiplayer games in JavaScript. \n\n\nThis framework is fairly new and is being evolved constantly. You're encouraged to take a look on \nsome games being developed with it\n and make your own!\n\n\nWhat Colyseus provides to you:\n\n\n\n\nWebSocket-based communication\n\n\nSimple API in the server-side and client-side.\n\n\nAutomatic state synchronization between server and client.\n\n\nMatchmaking clients into game sessions\n\n\nScale on many processes on a single machine.\n\n\n\n\nWhat Colyseus won't provide:\n\n\n\n\nGame Engine: Colyseus is agnostic of the engine you're using. Need Physics? Add your own logic / package.\n\n\nDatabase: It's up to configure and select which database you'd like to use.\n\n\n\n\nWhat people are saying about it?\n\n\n\n\n@bmovement\n\n\n\"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\"\n\n\n\n\n\n\n@sagestudios\n\n\nLoved the framework. Exactly what we are looking for in terms of features.\n\n\n\n\nExternal links\n\n\n\n\n\ud83c\udf10 \n Website\n\n\n\ud83d\udcac \n Forum\n\n\n\ud83d\udcb0 \n Support the project", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-colyseus-provides-to-you", 
            "text": "WebSocket-based communication  Simple API in the server-side and client-side.  Automatic state synchronization between server and client.  Matchmaking clients into game sessions  Scale on many processes on a single machine.", 
            "title": "What Colyseus provides to you:"
        }, 
        {
            "location": "/#what-colyseus-wont-provide", 
            "text": "Game Engine: Colyseus is agnostic of the engine you're using. Need Physics? Add your own logic / package.  Database: It's up to configure and select which database you'd like to use.", 
            "title": "What Colyseus won't provide:"
        }, 
        {
            "location": "/#what-people-are-saying-about-it", 
            "text": "@bmovement  \"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\"    @sagestudios  Loved the framework. Exactly what we are looking for in terms of features.", 
            "title": "What people are saying about it?"
        }, 
        {
            "location": "/#external-links", 
            "text": "\ud83c\udf10   Website  \ud83d\udcac   Forum  \ud83d\udcb0   Support the project", 
            "title": "External links"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started\n\n\nThe Mindset\n\n\nThe authoritative game server mindset is quite simple. The Server validates the user actions, and clients are dumb visual representations of the current game state.\n\n\nThe server should take care of all data involved in your game, such as positioning, speeds, collisions, etc.\n\n\nMaking multiplayer games is usually tricky because your gameplay must take the multiple delays into account - the other clients sending data to the server, and the server sending data back to all clients. It's the art of faking something that has already happened is actually happening as the current player sees and plays the game.\n\n\nHere's how the \"multiplayer game loop\" looks like on Colyseus:\n\n\n\n\nClient sends a message to the server, requesting to change its state.\n\n\nThe input must be validated by your room handler.\n\n\nThe game state is updated.\n\n\nAll clients receive the latest version of the game state.\n\n\nThe visual representation of the game state is updated.\n\n\n\n\nDiagram\n\n\n              room.send({ action: \nleft\n })                             \n\n                           |                                            \n      +------------+       |       +-----------------------------------+\n+-----+ Client #1  +-------|       |  Room handler #1                  |\n|     +------------+       |       |                                   |\n|     +------------+       |       |  onMessage (client, data) {       |\n|-----+ Client #2  |       --------+    if (data.action === \nleft\n) {  |\n|     +------------+               |      // update the room state     |\n|     +------------+               |    }                              |\n|-----+ Client #3  |               |  }                                |\n|     +------------+               +-----------------------------------+\n|                                                    |                  \n|        patch state broadcast (binary diff)         |                  \n|----------------------------------------------------+\n\n\n\n\n\nRecommended NodeJS packages for games\n\n\nThese modules can be useful while developing games on both NodeJS and the Browser.\n\n\n\n\n@gamestdio/mathf\n - Mathematical functions, borrowed from Unity3D's API\n\n\n@gamestdio/timer\n - Reliable timing events \n\n\n@gamestdio/keycode\n - Constants for keyboard key codes (\nevent.which\n)\n\n\n\n\nThese modules can be used only in the browser:\n\n\n\n\n@gamestdio/pixi-engine", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#the-mindset", 
            "text": "The authoritative game server mindset is quite simple. The Server validates the user actions, and clients are dumb visual representations of the current game state.  The server should take care of all data involved in your game, such as positioning, speeds, collisions, etc.  Making multiplayer games is usually tricky because your gameplay must take the multiple delays into account - the other clients sending data to the server, and the server sending data back to all clients. It's the art of faking something that has already happened is actually happening as the current player sees and plays the game.  Here's how the \"multiplayer game loop\" looks like on Colyseus:   Client sends a message to the server, requesting to change its state.  The input must be validated by your room handler.  The game state is updated.  All clients receive the latest version of the game state.  The visual representation of the game state is updated.", 
            "title": "The Mindset"
        }, 
        {
            "location": "/getting-started/#diagram", 
            "text": "room.send({ action:  left  })                             \n\n                           |                                            \n      +------------+       |       +-----------------------------------+\n+-----+ Client #1  +-------|       |  Room handler #1                  |\n|     +------------+       |       |                                   |\n|     +------------+       |       |  onMessage (client, data) {       |\n|-----+ Client #2  |       --------+    if (data.action ===  left ) {  |\n|     +------------+               |      // update the room state     |\n|     +------------+               |    }                              |\n|-----+ Client #3  |               |  }                                |\n|     +------------+               +-----------------------------------+\n|                                                    |                  \n|        patch state broadcast (binary diff)         |                  \n|----------------------------------------------------+", 
            "title": "Diagram"
        }, 
        {
            "location": "/getting-started/#recommended-nodejs-packages-for-games", 
            "text": "These modules can be useful while developing games on both NodeJS and the Browser.   @gamestdio/mathf  - Mathematical functions, borrowed from Unity3D's API  @gamestdio/timer  - Reliable timing events   @gamestdio/keycode  - Constants for keyboard key codes ( event.which )   These modules can be used only in the browser:   @gamestdio/pixi-engine", 
            "title": "Recommended NodeJS packages for games"
        }, 
        {
            "location": "/concept-state-synchronization/", 
            "text": "State synchronization\n\n\n\n\nColyseus uses \nMessagePack\n to encode the room state in a binary format.\n\n\nUpon first connection, the client receives the latest full binary room state.\n\n\nThe binary patch is evaluated through \nFossil's Delta algorithm\n at every \npatch interval\n.\n\n\nThe patched room state is sent to all connected clients.", 
            "title": "State synchronization"
        }, 
        {
            "location": "/concept-state-synchronization/#state-synchronization", 
            "text": "Colyseus uses  MessagePack  to encode the room state in a binary format.  Upon first connection, the client receives the latest full binary room state.  The binary patch is evaluated through  Fossil's Delta algorithm  at every  patch interval .  The patched room state is sent to all connected clients.", 
            "title": "State synchronization"
        }, 
        {
            "location": "/concept-matchmaking/", 
            "text": "", 
            "title": "Matchmaking"
        }, 
        {
            "location": "/concept-worker-processes/", 
            "text": "Worker processes\n\n\nClustered environment\n\n\nThe clustered environment is recommended for your production environment. To leverage from it, you'll need to use \nClusterServer\n class. \n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \ncluster\n \nfrom\n \ncluster\n;\n\n\nimport\n \n*\n \nas\n \npath\n \nfrom\n \npath\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n{\n \nClusterServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \nPORT\n \n=\n \n8080\n;\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n  \ngameServer\n.\nlisten\n(\nPORT\n);\n\n  \ngameServer\n.\nfork\n();\n\n\n\n}\n \nelse\n \n{\n\n  \nconst\n \napp\n \n=\n \nnew\n \nexpress\n();\n\n\n  \ngameServer\n.\nattach\n({\n \nserver\n: \napp\n \n});\n\n\n}\n\n\n\nconsole\n.\nlog\n(\n`Listening on \n${\n \nPORT\n \n}\n`\n);\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncluster\n \n=\n \nrequire\n(\ncluster\n);\n\n\nconst\n \npath\n \n=\n \nrequire\n(\npath\n);\n\n\nconst\n \nexpress\n \n=\n \nrequire\n(\nexpress\n);\n\n\nconst\n \nClusterServer\n \n=\n \nrequire\n(\ncolyseus\n).\nClusterServer\n;\n\n\n\nconst\n \nPORT\n \n=\n \n8080\n;\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n  \ngameServer\n.\nlisten\n(\nPORT\n);\n\n  \ngameServer\n.\nfork\n();\n\n\n\n}\n \nelse\n \n{\n\n  \nconst\n \napp\n \n=\n \nnew\n \nexpress\n();\n\n\n  \ngameServer\n.\nattach\n({\n \nserver\n: \napp\n \n});\n\n\n}\n\n\n\nconsole\n.\nlog\n(\n`Listening on \n${\n \nPORT\n \n}\n`\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nBy default, \nClusterServer\n spawn a worker process for each CPU available on the host machine.\n\n\n                +----------------+                                                      \n                | Master process |                                                      \n                +--------|-------+                                                      \n                         |                                                              \n              +----------+-----------+                                                  \n              | Match-making process |                                                  \n              +----------------------+                                                  \n                         |                                                              \n         +----------------                                                              \n         |                                                                              \n+--------|-------+----------------+----------------+                                    \n| Worker process | Worker process | Worker process |                                    \n+----------------+----------------+----------------+                                    \n  # FooRoom        # FooRoom        # QuxRoom                                           \n  # BarRoom                \n\n\n\n\n\nMaster process\n\n\nThe master process will handle redirecting the WebSocket connection to the suitable process. When not connected to a room, the Match-making process will be selected for that connection.\n\n\nMatch-making process\n\n\nThe Match-making process is responsible for responding to requests for joining a room/session. After the request has been completed, the client will establish a new WebSocket connection which will be redirected the Worker process that room is living in.\n\n\nWorker process\n\n\nEach Worker processes can handle multiple rooms / sessions.\n\n\nSingle process environment\n\n\nThe single process environment is lightweight and is best for local development and prototyping. You can deploy it on \nZeit Now\n or \nHeroku\n for free.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \nhttp\n \nfrom\n \nhttp\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \nport\n \n=\n \n8080\n;\n\n\nconst\n \nendpoint\n \n=\n \nlocalhost\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\n\n// Create HTTP \n WebSocket servers\n\n\nconst\n \nserver\n \n=\n \nhttp\n.\ncreateServer\n(\napp\n);\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n \nserver\n: \nserver\n \n});\n\n\n\n// Listen on port\n\n\ngameServer\n.\nlisten\n(\nport\n);\n\n\nconsole\n.\nlog\n(\n`Listening on http://\n${\n \nendpoint\n \n}\n:\n${\n \nport\n \n}\n`\n)\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \nhttp\n \n=\n \nrequire\n(\nhttp\n);\n\n\nconst\n \nexpress\n \n=\n \nrequire\n(\nexpress\n);\n\n\nconst\n \nServer\n \n=\n \nrequire\n(\ncolyseus\n).\nServer\n;\n\n\n\nconst\n \nport\n \n=\n \n8080\n;\n\n\nconst\n \nendpoint\n \n=\n \nlocalhost\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\n\n// Create HTTP \n WebSocket servers\n\n\nconst\n \nserver\n \n=\n \nhttp\n.\ncreateServer\n(\napp\n);\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n \nserver\n: \nserver\n \n});\n\n\n\n// Listen on port\n\n\ngameServer\n.\nlisten\n(\nport\n);\n\n\nconsole\n.\nlog\n(\n`Listening on http://\n${\n \nendpoint\n \n}\n:\n${\n \nport\n \n}\n`\n)", 
            "title": "Worker processes"
        }, 
        {
            "location": "/concept-worker-processes/#worker-processes", 
            "text": "", 
            "title": "Worker processes"
        }, 
        {
            "location": "/concept-worker-processes/#clustered-environment", 
            "text": "The clustered environment is recommended for your production environment. To leverage from it, you'll need to use  ClusterServer  class.   \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   cluster   from   cluster ;  import   *   as   path   from   path ;  import   *   as   express   from   express ;  import   {   ClusterServer   }   from   colyseus ;  const   PORT   =   8080 ;  const   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n   gameServer . listen ( PORT ); \n   gameServer . fork ();  }   else   { \n   const   app   =   new   express (); \n\n   gameServer . attach ({   server :  app   });  }  console . log ( `Listening on  ${   PORT   } ` );  \n\n         \n    \n         \n             const   cluster   =   require ( cluster );  const   path   =   require ( path );  const   express   =   require ( express );  const   ClusterServer   =   require ( colyseus ). ClusterServer ;  const   PORT   =   8080 ;  const   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n   gameServer . listen ( PORT ); \n   gameServer . fork ();  }   else   { \n   const   app   =   new   express (); \n\n   gameServer . attach ({   server :  app   });  }  console . log ( `Listening on  ${   PORT   } ` );  \n\n         \n    \n         \n    \n                 \n                      By default,  ClusterServer  spawn a worker process for each CPU available on the host machine.                  +----------------+                                                      \n                | Master process |                                                      \n                +--------|-------+                                                      \n                         |                                                              \n              +----------+-----------+                                                  \n              | Match-making process |                                                  \n              +----------------------+                                                  \n                         |                                                              \n         +----------------                                                              \n         |                                                                              \n+--------|-------+----------------+----------------+                                    \n| Worker process | Worker process | Worker process |                                    \n+----------------+----------------+----------------+                                    \n  # FooRoom        # FooRoom        # QuxRoom                                           \n  # BarRoom", 
            "title": "Clustered environment"
        }, 
        {
            "location": "/concept-worker-processes/#master-process", 
            "text": "The master process will handle redirecting the WebSocket connection to the suitable process. When not connected to a room, the Match-making process will be selected for that connection.", 
            "title": "Master process"
        }, 
        {
            "location": "/concept-worker-processes/#match-making-process", 
            "text": "The Match-making process is responsible for responding to requests for joining a room/session. After the request has been completed, the client will establish a new WebSocket connection which will be redirected the Worker process that room is living in.", 
            "title": "Match-making process"
        }, 
        {
            "location": "/concept-worker-processes/#worker-process", 
            "text": "Each Worker processes can handle multiple rooms / sessions.", 
            "title": "Worker process"
        }, 
        {
            "location": "/concept-worker-processes/#single-process-environment", 
            "text": "The single process environment is lightweight and is best for local development and prototyping. You can deploy it on  Zeit Now  or  Heroku  for free.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   http   from   http ;  import   *   as   express   from   express ;  import   {   Server   }   from   colyseus ;  const   port   =   8080 ;  const   endpoint   =   localhost ;  const   app   =   express ();  // Create HTTP   WebSocket servers  const   server   =   http . createServer ( app );  const   gameServer   =   new   Server ({   server :  server   });  // Listen on port  gameServer . listen ( port );  console . log ( `Listening on http:// ${   endpoint   } : ${   port   } ` )  \n\n         \n    \n         \n             const   http   =   require ( http );  const   express   =   require ( express );  const   Server   =   require ( colyseus ). Server ;  const   port   =   8080 ;  const   endpoint   =   localhost ;  const   app   =   express ();  // Create HTTP   WebSocket servers  const   server   =   http . createServer ( app );  const   gameServer   =   new   Server ({   server :  server   });  // Listen on port  gameServer . listen ( port );  console . log ( `Listening on http:// ${   endpoint   } : ${   port   } ` )", 
            "title": "Single process environment"
        }, 
        {
            "location": "/api-server/", 
            "text": "Web-Socket Server\n\n\nThe \nServer\n and \nClusterServer\n have pretty much the same API. \n\n\nThey're responsible for providing the WebSocket server to enable communication between server and client.\n\n\nServer\n\n\nRecommended for development and prototyping environments.\n\n\nregister (name: string, handler: Room, options?: any)\n\n\nRegister a new session handler. \n\n\nParameters:\n\n\n\n\nname: string\n - The public name of the room. You'll use this name when joining the room from the client-side.\n\n\nhandler: Room\n - Reference to the \nRoom\n handler class.\n\n\noptions?: any\n - Custom options for room initialization.\n\n\n\n\n// Register \nchat\n room\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n);\n\n\n\n// Register \nbattle\n room\n\n\ngameServer\n.\nregister\n(\nbattle\n,\n \nBattleRoom\n);\n\n\n\n\n\n\n\n\nTip\n\n\nYou may register the same room handler multiple times with different \noptions\n. When \nRoom#onInit()\n is called, the \noptions\n will contain the merged values you specified on \nServer#register()\n + the options provided by the first client on \nclient.join()\n\n\n\n\nattach (options: any)\n\n\nAttaches or creates the WebSocket server.\n\n\n\n\noptions.server\n: The HTTP server to attach the WebSocket server on.\n\n\noptions.ws\n: An existing WebSocket server to be re-used.\n\n\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nExpress\n\n        \n\n    \n        \n\n            \nhttp.createServer\n\n        \n\n    \n        \n\n            \nWebSocket.Server\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \napp\n \n=\n \nnew\n \nexpress\n();\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n();\n\n\n\ngameServer\n.\nattach\n({\n \nserver\n:\n \napp\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n*\n \nas\n \nhttp\n \nfrom\n \nhttp\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \nhttpServer\n \n=\n \nhttp\n.\ncreateServer\n();\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n();\n\n\n\ngameServer\n.\nattach\n({\n \nserver\n:\n \nhttpServer\n \n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n*\n \nas\n \nhttp\n \nfrom\n \nhttp\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\nimport\n \n*\n \nas\n \nws\n \nfrom\n \nws\n;\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\nconst\n \nserver\n \n=\n \nhttp\n.\ncreateServer\n(\napp\n);\n\n\nconst\n \nwss\n \n=\n \nnew\n \nWebSocket\n.\nServer\n({\n\n    \n// your custom WebSocket.Server setup.\n\n\n});\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n();\n\n\ngameServer\n.\nattach\n({\n \nws\n:\n \nwss\n \n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nlisten (port: number)\n\n\nBinds the WebSocket server into the specified port.\n\n\nonShutdown (callback: Function)\n\n\nRegister a callback that should be called before the process shut down. See \ngraceful shutdown\n for more details.\n\n\nClusterServer\n\n\nRecommended for production environment. \n\n\nThe \nClusterServer\n has the same functionality of \nServer\n, with some caveats. You'll need to use the \n\"cluster\"\n module by yourself and call its methods in the right node type. \n\n\nSee \nClustered environment\n for more details.\n\n\nfork (workers?: number)\n\n\nSpecify the number of session workers to spawn. By default it uses the number of available CPUs.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \ncluster\n \nfrom\n \ncluster\n;\n\n\nimport\n \n{\n \nClusterServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nlet\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n    \ngameServer\n.\nlisten\n(\n8080\n);\n\n    \ngameServer\n.\nfork\n(\n4\n);\n\n\n\n}\n \nelse\n \n{\n\n    \n// ...\n\n\n}\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncluster\n \n=\n \nrequire\n(\ncluster\n);\n\n\nconst\n \nClusterServer\n \n=\n \nrequire\n(\ncolyseus\n).\nClusterServer\n;\n\n\n\nlet\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n    \ngameServer\n.\nlisten\n(\n8080\n);\n\n    \ngameServer\n.\nfork\n(\n4\n);\n\n\n\n}\n \nelse\n \n{\n\n    \n// ...\n\n\n}", 
            "title": "Web-Socket Server"
        }, 
        {
            "location": "/api-server/#web-socket-server", 
            "text": "The  Server  and  ClusterServer  have pretty much the same API.   They're responsible for providing the WebSocket server to enable communication between server and client.", 
            "title": "Web-Socket Server"
        }, 
        {
            "location": "/api-server/#server", 
            "text": "Recommended for development and prototyping environments.", 
            "title": "Server"
        }, 
        {
            "location": "/api-server/#register-name-string-handler-room-options-any", 
            "text": "Register a new session handler.   Parameters:   name: string  - The public name of the room. You'll use this name when joining the room from the client-side.  handler: Room  - Reference to the  Room  handler class.  options?: any  - Custom options for room initialization.   // Register  chat  room  gameServer . register ( chat ,   ChatRoom );  // Register  battle  room  gameServer . register ( battle ,   BattleRoom );    Tip  You may register the same room handler multiple times with different  options . When  Room#onInit()  is called, the  options  will contain the merged values you specified on  Server#register()  + the options provided by the first client on  client.join()", 
            "title": "register (name: string, handler: Room, options?: any)"
        }, 
        {
            "location": "/api-server/#attach-options-any", 
            "text": "Attaches or creates the WebSocket server.   options.server : The HTTP server to attach the WebSocket server on.  options.ws : An existing WebSocket server to be re-used.   \n                 \n                    \n         \n            \n         \n             Express \n         \n    \n         \n             http.createServer \n         \n    \n         \n             WebSocket.Server \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   express   from   express ;  import   {   Server   }   from   colyseus ;  const   app   =   new   express ();  const   gameServer   =   new   Server ();  gameServer . attach ({   server :   app   });  \n\n         \n    \n         \n             import   *   as   http   from   http ;  import   {   Server   }   from   colyseus ;  const   httpServer   =   http . createServer ();  const   gameServer   =   new   Server ();  gameServer . attach ({   server :   httpServer   });  \n\n         \n    \n         \n             import   *   as   http   from   http ;  import   *   as   express   from   express ;  import   *   as   ws   from   ws ;  import   {   Server   }   from   colyseus ;  const   app   =   express ();  const   server   =   http . createServer ( app );  const   wss   =   new   WebSocket . Server ({ \n     // your custom WebSocket.Server setup.  });  const   gameServer   =   new   Server ();  gameServer . attach ({   ws :   wss   });", 
            "title": "attach (options: any)"
        }, 
        {
            "location": "/api-server/#listen-port-number", 
            "text": "Binds the WebSocket server into the specified port.", 
            "title": "listen (port: number)"
        }, 
        {
            "location": "/api-server/#onshutdown-callback-function", 
            "text": "Register a callback that should be called before the process shut down. See  graceful shutdown  for more details.", 
            "title": "onShutdown (callback: Function)"
        }, 
        {
            "location": "/api-server/#clusterserver", 
            "text": "Recommended for production environment.   The  ClusterServer  has the same functionality of  Server , with some caveats. You'll need to use the  \"cluster\"  module by yourself and call its methods in the right node type.   See  Clustered environment  for more details.", 
            "title": "ClusterServer"
        }, 
        {
            "location": "/api-server/#fork-workers-number", 
            "text": "Specify the number of session workers to spawn. By default it uses the number of available CPUs.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   cluster   from   cluster ;  import   {   ClusterServer   }   from   colyseus ;  let   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n     gameServer . listen ( 8080 ); \n     gameServer . fork ( 4 );  }   else   { \n     // ...  }  \n\n         \n    \n         \n             const   cluster   =   require ( cluster );  const   ClusterServer   =   require ( colyseus ). ClusterServer ;  let   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n     gameServer . listen ( 8080 ); \n     gameServer . fork ( 4 );  }   else   { \n     // ...  }", 
            "title": "fork (workers?: number)"
        }, 
        {
            "location": "/api-room/", 
            "text": "Room API\n\n\nConsidering that you already \nset up your server\n, now it's time to register session handlers, and start accepting connections from your users.\n\n\nYou'll define session handlers creating classes that extends from \nRoom\n.\n\n\nimport\n \n{\n \nRoom\n,\n \nClient\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nexport\n \nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \n// When room is initialized\n\n    \nonInit\n \n(\noptions\n: \nany\n)\n \n{\n \n}\n \n\n    \n// Checks if a new client is allowed to join. (default: `return true`)\n\n    \nrequestJoin\n \n(\noptions\n: \nany\n)\n \n{\n \n}\n \n\n    \n// When client successfully join the room\n\n    \nonJoin\n \n(\nclient\n: \nClient\n)\n \n{\n \n}\n \n\n    \n// When a client leaves the room\n\n    \nonLeave\n \n(\nclient\n: \nClient\n)\n \n{\n \n}\n \n\n    \n// When a client sends a message\n\n    \nonMessage\n \n(\nclient\n: \nClient\n,\n \ndata\n: \nany\n)\n \n{\n \n}\n \n\n    \n// Cleanup callback, called after there are no more clients in the room. (see `autoDispose`)\n\n    \nonDispose\n \n()\n \n{\n \n}\n\n\n}\n\n\n\n\n\n\nAbstract methods\n\n\nRoom handlers can implement all these methods.\n\n\nonInit (options)\n\n\nIs called once when room is initialized. You may specify custom initialization options when registering the room handler.\n\n\n\n\nTip\n\n\nThe \noptions\n will contain the merged values you specified on \nServer#register()\n + the options provided by the first client on \nclient.join()\n\n\n\n\nverifyClient (client, options)\n\n\nCan be used to verify authenticity of the client that's joining the room. \n\n\nIf left non-implemented it returns \ntrue\n, allowing any client to connect.\n\n\nSee \nauthentication\n section.\n\n\nrequestJoin (options)\n\n\nSynchronous function used to checks if a new client is allowed to join. \n\n\nIf left non-implemented it returns \ntrue\n, allowing any client to connect.\n\n\nonJoin (client)\n\n\nIs called when client successfully join the room, after \nrequestJoin\n and \nverifyClient\n succeeded.\n\n\nonMessage (client, data)\n\n\nIs called when a client sends a message to the server. Here's where you'll process client actions to update the room's state.\n\n\nExample:\n\n\nonMessage\n \n(\nclient\n,\n \ndata\n)\n \n{\n\n    \nlet\n \nplayer\n \n=\n \nthis\n.\nplayersByClientId\n.\nget\n(\nclient\n);\n\n\n    \nif\n \n(\ndata\n.\ncommand\n \n===\n \nleft\n)\n \n{\n\n        \nplayer\n.\nx\n \n-=\n \n1\n;\n\n\n    \n}\n \nelse\n \nif\n \n(\ndata\n.\ncommand\n \n===\n \nright\n)\n \n{\n\n        \nplayer\n.\nx\n \n+=\n \n1\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nonLeave (client)\n\n\nIs called when a client leave the room. \n\n\nYou can define this function as \nasync\n. See \ngraceful shutdown\n\n\nonDispose ()\n\n\nCleanup callback, called after there are no more clients in the room.\n\n\nYou can define this function as \nasync\n. See \ngraceful shutdown\n\n\nPublic properties\n\n\nclients: WebSocket[]\n\n\nThe array of connected clients.\n\n\nmaxClients: number\n\n\nMaximum number of clients allowed to connect into the room\n\n\npatchRate: number\n\n\nFrequency to send the room state to connected clients (in milliseconds)\n\n\nSee \nstate synchronization\n.\n\n\nautoDispose: boolean\n\n\nAutomatically dispose the room when last client disconnect. (default: \ntrue\n)\n\n\nclock: ClockTimer\n\n\nA \nClockTimer\n instance.\n\n\nPublic methods\n\n\nRoom handlers have these methods available.\n\n\nsetState (object)\n\n\nSet the new room state. \n\n\n\n\nTip\n\n\nYou'll usually call this method only once in your handler.\n\n\n\n\nSet the current state to be broadcasted / patched.\n\n\nsetSimulationInterval (callback[, milliseconds=16.6])\n\n\n(Optional) Create the simulation interval that will change the state of the game. Default simulation interval: 16.6ms (60fps)\n\n\nsetPatchRate (milliseconds)\n\n\nSet frequency the patched state should be sent to all clients. (default: \n50\n = 20fps)\n\n\nsend (client, data)\n\n\nSend data to a particular client\n\n\nlock ()\n\n\nLocking the room will remove it from the pool of available rooms for new clients to connect to.\n\n\nunlock ()\n\n\nUnlocking the room returns it to the pool of available rooms for new clients to connect to.\n\n\nbroadcast ( data )\n\n\nSend raw data to all connected clients.\n\n\ndisconnect ()\n\n\nDisconnect all clients, then dispose", 
            "title": "Room"
        }, 
        {
            "location": "/api-room/#room-api", 
            "text": "Considering that you already  set up your server , now it's time to register session handlers, and start accepting connections from your users.  You'll define session handlers creating classes that extends from  Room .  import   {   Room ,   Client   }   from   colyseus ;  export   class   MyRoom   extends   Room   { \n     // When room is initialized \n     onInit   ( options :  any )   {   }  \n\n     // Checks if a new client is allowed to join. (default: `return true`) \n     requestJoin   ( options :  any )   {   }  \n\n     // When client successfully join the room \n     onJoin   ( client :  Client )   {   }  \n\n     // When a client leaves the room \n     onLeave   ( client :  Client )   {   }  \n\n     // When a client sends a message \n     onMessage   ( client :  Client ,   data :  any )   {   }  \n\n     // Cleanup callback, called after there are no more clients in the room. (see `autoDispose`) \n     onDispose   ()   {   }  }", 
            "title": "Room API"
        }, 
        {
            "location": "/api-room/#abstract-methods", 
            "text": "Room handlers can implement all these methods.", 
            "title": "Abstract methods"
        }, 
        {
            "location": "/api-room/#oninit-options", 
            "text": "Is called once when room is initialized. You may specify custom initialization options when registering the room handler.   Tip  The  options  will contain the merged values you specified on  Server#register()  + the options provided by the first client on  client.join()", 
            "title": "onInit (options)"
        }, 
        {
            "location": "/api-room/#verifyclient-client-options", 
            "text": "Can be used to verify authenticity of the client that's joining the room.   If left non-implemented it returns  true , allowing any client to connect.  See  authentication  section.", 
            "title": "verifyClient (client, options)"
        }, 
        {
            "location": "/api-room/#requestjoin-options", 
            "text": "Synchronous function used to checks if a new client is allowed to join.   If left non-implemented it returns  true , allowing any client to connect.", 
            "title": "requestJoin (options)"
        }, 
        {
            "location": "/api-room/#onjoin-client", 
            "text": "Is called when client successfully join the room, after  requestJoin  and  verifyClient  succeeded.", 
            "title": "onJoin (client)"
        }, 
        {
            "location": "/api-room/#onmessage-client-data", 
            "text": "Is called when a client sends a message to the server. Here's where you'll process client actions to update the room's state.  Example:  onMessage   ( client ,   data )   { \n     let   player   =   this . playersByClientId . get ( client ); \n\n     if   ( data . command   ===   left )   { \n         player . x   -=   1 ; \n\n     }   else   if   ( data . command   ===   right )   { \n         player . x   +=   1 ; \n     }  }", 
            "title": "onMessage (client, data)"
        }, 
        {
            "location": "/api-room/#onleave-client", 
            "text": "Is called when a client leave the room.   You can define this function as  async . See  graceful shutdown", 
            "title": "onLeave (client)"
        }, 
        {
            "location": "/api-room/#ondispose", 
            "text": "Cleanup callback, called after there are no more clients in the room.  You can define this function as  async . See  graceful shutdown", 
            "title": "onDispose ()"
        }, 
        {
            "location": "/api-room/#public-properties", 
            "text": "", 
            "title": "Public properties"
        }, 
        {
            "location": "/api-room/#clients-websocket", 
            "text": "The array of connected clients.", 
            "title": "clients: WebSocket[]"
        }, 
        {
            "location": "/api-room/#maxclients-number", 
            "text": "Maximum number of clients allowed to connect into the room", 
            "title": "maxClients: number"
        }, 
        {
            "location": "/api-room/#patchrate-number", 
            "text": "Frequency to send the room state to connected clients (in milliseconds)  See  state synchronization .", 
            "title": "patchRate: number"
        }, 
        {
            "location": "/api-room/#autodispose-boolean", 
            "text": "Automatically dispose the room when last client disconnect. (default:  true )", 
            "title": "autoDispose: boolean"
        }, 
        {
            "location": "/api-room/#clock-clocktimer", 
            "text": "A  ClockTimer  instance.", 
            "title": "clock: ClockTimer"
        }, 
        {
            "location": "/api-room/#public-methods", 
            "text": "Room handlers have these methods available.", 
            "title": "Public methods"
        }, 
        {
            "location": "/api-room/#setstate-object", 
            "text": "Set the new room state.    Tip  You'll usually call this method only once in your handler.   Set the current state to be broadcasted / patched.", 
            "title": "setState (object)"
        }, 
        {
            "location": "/api-room/#setsimulationinterval-callback-milliseconds166", 
            "text": "(Optional) Create the simulation interval that will change the state of the game. Default simulation interval: 16.6ms (60fps)", 
            "title": "setSimulationInterval (callback[, milliseconds=16.6])"
        }, 
        {
            "location": "/api-room/#setpatchrate-milliseconds", 
            "text": "Set frequency the patched state should be sent to all clients. (default:  50  = 20fps)", 
            "title": "setPatchRate (milliseconds)"
        }, 
        {
            "location": "/api-room/#send-client-data", 
            "text": "Send data to a particular client", 
            "title": "send (client, data)"
        }, 
        {
            "location": "/api-room/#lock", 
            "text": "Locking the room will remove it from the pool of available rooms for new clients to connect to.", 
            "title": "lock ()"
        }, 
        {
            "location": "/api-room/#unlock", 
            "text": "Unlocking the room returns it to the pool of available rooms for new clients to connect to.", 
            "title": "unlock ()"
        }, 
        {
            "location": "/api-room/#broadcast-data", 
            "text": "Send raw data to all connected clients.", 
            "title": "broadcast ( data )"
        }, 
        {
            "location": "/api-room/#disconnect", 
            "text": "Disconnect all clients, then dispose", 
            "title": "disconnect ()"
        }, 
        {
            "location": "/api-room-state/", 
            "text": "The room handlers are \nstateful\n in Colyseus. Each room holds its own state. To allow \nsynchronization\n, you \nmust\n mutate the room's state. The server automatically broadcasts the changes to all connected clients at each patch interval.\n\n\nRaw Object State\n\n\nThe simplest way to deal with the room state is using a raw JavaScript objects directly in the \nRoom\n handler.\n\n\nimport\n \n{\n \nRoom\n,\n \nClient\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nBattleRoom\n \nextends\n \nRoom\n \n{\n\n\n  \nonInit\n \n(\noptions\n: \nany\n)\n \n{\n\n    \nthis\n.\nsetState\n({\n\n      \nmessages\n:\n \n[]\n\n    \n});\n\n  \n}\n\n\n  \nonMessage\n \n(\nclient\n: \nClient\n,\n \ndata\n: \nany\n)\n \n{\n\n    \nthis\n.\nstate\n.\nmessages\n.\npush\n(\ndata\n.\nmessage\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nBest practices\n\n\nData structures\n\n\nUse small data structures to re\n\n\nMap of entities (\nEntityMap\n)\n\n\nPrivate variables (\n@nosync\n)\n\n\nAvoid mutating arrays\n\n\nYou can use arrays in your room's state. If possible, avoid mutating them because it's tricky to synchronize the state properly in the client-side when you do.\n\n\nState Handler Class\n\n\nEven though you can use plain objects to define the state directly in the room handler, the recommended way is to define your own data structures for it, and methods to manipulate the state inside these data structures.\n\n\nYou can use the \n@nosync\n decorator to define data that won't be synched with the clients (non-enumerable).\n\n\nimport\n \n{\n \nnosync\n,\n \nEntityMap\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nexport\n \nclass\n \nStateHandler\n \n{\n\n  \nplayers\n: \nany\n \n=\n \n{};\n\n\n  \n@nosync\n \nmapBuilder\n \n=\n  \nnew\n \nMapBuilder\n();\n\n\n  \nconstructor\n \n()\n \n{\n\n    \nthis\n.\nplayers\n \n=\n \n{};\n\n    \nthis\n.\nmap\n \n=\n \nthis\n.\nmapBuilder\n.\nbuild\n();\n\n  \n}\n\n\n  \nrestart\n \n()\n \n{\n\n    \nthis\n.\nmap\n \n=\n \nthis\n.\nmapBuilder\n.\nbuild\n();\n\n  \n}\n\n\n  \naddPlayer\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nplayers\n[\n \nclient\n.\nid\n \n]\n \n=\n \n{};\n\n  \n}\n\n\n  \nremovePlayer\n \n(\nclient\n)\n \n{\n\n    \ndelete\n \nthis\n.\nplayers\n[\n \nclient\n.\nid\n \n];\n\n  \n}\n\n\n\n}\n\n\n\n\n\n\nOn this example, the \nStateHandler\n creates a \nMapBuilder\n instance (that won't be visible in the client-side), which would be responsible for creating the map data. It exposes some methods to be called from the parent \nRoom\n instance, such as \naddPlayer\n and \nrestart\n.\n\n\nTo use this \nStateHandler\n class in a \nRoom\n instance it would look like this:\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n\n\nimport\n \n{\n \nStateHandler\n \n}\n \nfrom\n \n./StateHandler\n;\n\n\n\nexport\n \nclass\n \nMapRoom\n \nextends\n \nRoom\nStateHandler\n \n{\n\n  \nonInit\n \n(\noptions\n)\n \n{\n\n\n    \n// sync state every 50ms\n\n    \nthis\n.\nsetPatchRate\n(\n \n1000\n \n/\n \n20\n \n);\n\n\n    \n// initialize StateHandler\n\n    \nthis\n.\nsetState\n(\n \nnew\n \nStateHandler\n()\n \n);\n\n\n    \n// reset the state every 3 minutes\n\n    \nsetInterval\n(()\n \n=\n \nthis\n.\nstate\n.\nrestart\n(),\n \n1000\n \n*\n \n60\n \n*\n \n3\n);\n\n  \n}\n\n\n  \nonJoin\n \n(\nclient\n)\n \n{\n\n    \n// add player instance to room state\n\n    \nthis\n.\nstate\n.\naddPlayer\n(\nclient\n);\n\n  \n}\n\n\n  \nonLeave\n \n(\nclient\n)\n \n{\n\n    \n// add player instance to room state\n\n    \nthis\n.\nstate\n.\nremovePlayer\n(\nclient\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nYou can go on and define more data structures for any kind of object you need. Let's define the \nPlayer\n now.\n\n\nexport\n \nclass\n \nPlayer\n \n{\n\n  \nlife\n: \nnumber\n \n=\n \n50\n;\n\n  \nmaxLife\n: \nnumber\n \n=\n \n50\n;\n\n  \ndamage\n: \nnumber\n \n=\n \n9\n;\n\n\n  \nconstructor\n \n()\n \n{\n\n    \n// recovers a life a little every 2 seconds\n\n    \nsetInterval\n(()\n \n=\n \nthis\n.\nrecoverLife\n(),\n \n2000\n);\n\n  \n}\n\n\n  \nrecoverLife\n \n()\n \n{\n\n    \nif\n \n(\nthis\n.\nlife\n \n \nthis\n.\nmaxLife\n)\n \n{\n\n      \nthis\n.\nlife\n++\n\n    \n}\n\n  \n}\n\n\n  \ntakeDamage\n \n(\notherPlayer\n)\n \n{\n\n    \nthis\n.\nlife\n \n-=\n \notherPlayer\n.\ndamage\n\n  \n}\n\n\n}\n\n\n\n\n\n\nHaving defined the \nPlayer\n class, you'd instantiate it rather than using plain objects in the \nStateHandler#addPlayer\n method:\n\n\n// StateHandler.ts\n\n\n// ...\n\n  \naddPlayer\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nplayers\n[\n \nclient\n.\nid\n \n]\n \n=\n \nnew\n \nPlayer\n();\n\n  \n}\n\n\n// ...", 
            "title": "State management"
        }, 
        {
            "location": "/api-room-state/#raw-object-state", 
            "text": "The simplest way to deal with the room state is using a raw JavaScript objects directly in the  Room  handler.  import   {   Room ,   Client   }   from   colyseus ;  class   BattleRoom   extends   Room   { \n\n   onInit   ( options :  any )   { \n     this . setState ({ \n       messages :   [] \n     }); \n   } \n\n   onMessage   ( client :  Client ,   data :  any )   { \n     this . state . messages . push ( data . message ); \n   }  }", 
            "title": "Raw Object State"
        }, 
        {
            "location": "/api-room-state/#best-practices", 
            "text": "", 
            "title": "Best practices"
        }, 
        {
            "location": "/api-room-state/#data-structures", 
            "text": "Use small data structures to re", 
            "title": "Data structures"
        }, 
        {
            "location": "/api-room-state/#map-of-entities-entitymap", 
            "text": "", 
            "title": "Map of entities (EntityMap)"
        }, 
        {
            "location": "/api-room-state/#private-variables-nosync", 
            "text": "", 
            "title": "Private variables (@nosync)"
        }, 
        {
            "location": "/api-room-state/#avoid-mutating-arrays", 
            "text": "You can use arrays in your room's state. If possible, avoid mutating them because it's tricky to synchronize the state properly in the client-side when you do.", 
            "title": "Avoid mutating arrays"
        }, 
        {
            "location": "/api-room-state/#state-handler-class", 
            "text": "Even though you can use plain objects to define the state directly in the room handler, the recommended way is to define your own data structures for it, and methods to manipulate the state inside these data structures.  You can use the  @nosync  decorator to define data that won't be synched with the clients (non-enumerable).  import   {   nosync ,   EntityMap   }   from   colyseus ;  export   class   StateHandler   { \n   players :  any   =   {}; \n\n   @nosync   mapBuilder   =    new   MapBuilder (); \n\n   constructor   ()   { \n     this . players   =   {}; \n     this . map   =   this . mapBuilder . build (); \n   } \n\n   restart   ()   { \n     this . map   =   this . mapBuilder . build (); \n   } \n\n   addPlayer   ( client )   { \n     this . players [   client . id   ]   =   {}; \n   } \n\n   removePlayer   ( client )   { \n     delete   this . players [   client . id   ]; \n   }  }   On this example, the  StateHandler  creates a  MapBuilder  instance (that won't be visible in the client-side), which would be responsible for creating the map data. It exposes some methods to be called from the parent  Room  instance, such as  addPlayer  and  restart .  To use this  StateHandler  class in a  Room  instance it would look like this:  import   {   Room   }   from   colyseus  import   {   StateHandler   }   from   ./StateHandler ;  export   class   MapRoom   extends   Room StateHandler   { \n   onInit   ( options )   { \n\n     // sync state every 50ms \n     this . setPatchRate (   1000   /   20   ); \n\n     // initialize StateHandler \n     this . setState (   new   StateHandler ()   ); \n\n     // reset the state every 3 minutes \n     setInterval (()   =   this . state . restart (),   1000   *   60   *   3 ); \n   } \n\n   onJoin   ( client )   { \n     // add player instance to room state \n     this . state . addPlayer ( client ); \n   } \n\n   onLeave   ( client )   { \n     // add player instance to room state \n     this . state . removePlayer ( client ); \n   }  }   You can go on and define more data structures for any kind of object you need. Let's define the  Player  now.  export   class   Player   { \n   life :  number   =   50 ; \n   maxLife :  number   =   50 ; \n   damage :  number   =   9 ; \n\n   constructor   ()   { \n     // recovers a life a little every 2 seconds \n     setInterval (()   =   this . recoverLife (),   2000 ); \n   } \n\n   recoverLife   ()   { \n     if   ( this . life     this . maxLife )   { \n       this . life ++ \n     } \n   } \n\n   takeDamage   ( otherPlayer )   { \n     this . life   -=   otherPlayer . damage \n   }  }   Having defined the  Player  class, you'd instantiate it rather than using plain objects in the  StateHandler#addPlayer  method:  // StateHandler.ts  // ... \n   addPlayer   ( client )   { \n     this . players [   client . id   ]   =   new   Player (); \n   }  // ...", 
            "title": "State Handler Class"
        }, 
        {
            "location": "/api-authentication/", 
            "text": "You may implement the \nverifyClient(client, options)\n method validate the authenticity of your clients. \n\n\nWhen requesting to join a room, that's the order of methods which will be called in your room handler:\n\n\n\n\nrequestJoin\n - should check if a room is available for new clients\n\n\nverifyClient (client, options)\n - should validate the client based on the options provided (i.e. auth token)\n\n\nonJoin (client, options)\n - should initialize the newly connected client into your room's state.\n\n\n\n\nFrom the client-side, you'd call the \njoin\n method with a token from some authentication service (i. e. Facebook):\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\njoin\n(\nworld\n,\n \n{\n\n  \naccessToken\n:\n \nyourFacebookAccessToken\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nJoin\n(\nworld\n,\n \nnew\n \n{\n\n  \naccessToken\n \n=\n \nyourFacebookAccessToken\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nThe \nverifyClient\n method in your room handler should return \ntrue\n only if the access token is valid.\n\n\nSynchronous usage\n\n\nYou can immediatelly return a \nboolean\n value.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nverifyClient\n \n(\nclient\n,\n \noptions\n)\n:\n \nboolean\n \n{\n\n    \nreturn\n \n(\noptions\n.\npassword\n \n===\n \nsecret\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAsynchronous usage\n\n\nYou can return a \nPromise\n, and perform some asynchronous task to validate the client.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nverifyClient\n \n(\nclient\n,\n \noptions\n)\n:\n \nPromise\n \n{\n\n    \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n      \nvalidateToken\n(\noptions\n.\naccessToken\n,\n \n(\nerr\n,\n \nsuccess\n)\n \n=\n \n{\n\n        \nif\n \n(\n!\nerr\n)\n \n{\n \n          \nresolve\n();\n\n        \n}\n \nelse\n \n{\n\n          \nreject\n(\nerr\n);\n\n        \n}\n\n      \n});\n\n    \n});\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAlternatively, you can use \nasync\n / \nawait\n, which will return a \nPromise\n under the hood.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nasync\n \nverifyClient\n \n(\nclient\n,\n \noptions\n)\n \n{\n\n    \nconst\n \nuserData\n \n=\n \nawait\n \nvalidateToken\n(\noptions\n.\naccessToken\n);\n\n    \nreturn\n \n(\nuserData\n)\n \n?\n \ntrue\n \n:\n \nfalse\n;\n\n  \n}\n\n\n}", 
            "title": "Authentication"
        }, 
        {
            "location": "/api-authentication/#synchronous-usage", 
            "text": "You can immediatelly return a  boolean  value.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   verifyClient   ( client ,   options ) :   boolean   { \n     return   ( options . password   ===   secret ); \n   }  }", 
            "title": "Synchronous usage"
        }, 
        {
            "location": "/api-authentication/#asynchronous-usage", 
            "text": "You can return a  Promise , and perform some asynchronous task to validate the client.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   verifyClient   ( client ,   options ) :   Promise   { \n     return   new   Promise (( resolve ,   reject )   =   { \n       validateToken ( options . accessToken ,   ( err ,   success )   =   { \n         if   ( ! err )   {  \n           resolve (); \n         }   else   { \n           reject ( err ); \n         } \n       }); \n     }); \n   }  }   Alternatively, you can use  async  /  await , which will return a  Promise  under the hood.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   async   verifyClient   ( client ,   options )   { \n     const   userData   =   await   validateToken ( options . accessToken ); \n     return   ( userData )   ?   true   :   false ; \n   }  }", 
            "title": "Asynchronous usage"
        }, 
        {
            "location": "/api-graceful-shutdown/", 
            "text": "Graceful Shutdown\n\n\nColyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself:\n\n\n\n\nDisconnect all connected clients asynchronously (\nRoom#onLeave\n)\n\n\nDispose all spawned rooms asynchronously (\nRoom#onDispose\n)\n\n\nPerform optional asynchronous callback before shutting down the process (\nServer#onShutdown\n / \nClusterServer#onShutdown\n)\n\n\n\n\nIf you're performing async tasks on \nonLeave\n / \nonDispose\n, you should return a \nPromise\n, and resolve it when the task is ready. The same applies to \nonShutdown(callback)\n.\n\n\nReturning a \nPromise\n\n\nBy returning a \nPromise\n, the server will wait for them to be completed before killing the worker process.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonLeave\n \n(\nclient\n)\n \n{\n\n        \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n            \ndoDatabaseOperation\n((\nerr\n,\n \ndata\n)\n \n=\n \n{\n\n                \nif\n \n(\nerr\n)\n \n{\n\n                    \nreject\n(\nerr\n);\n\n                \n}\n \nelse\n \n{\n\n                    \nresolve\n(\ndata\n);\n\n                \n}\n\n            \n});\n\n        \n});\n\n    \n}\n\n\n    \nonDispose\n \n()\n \n{\n\n        \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n            \ndoDatabaseOperation\n((\nerr\n,\n \ndata\n)\n \n=\n \n{\n\n                \nif\n \n(\nerr\n)\n \n{\n\n                    \nreject\n(\nerr\n);\n\n                \n}\n \nelse\n \n{\n\n                    \nresolve\n(\ndata\n);\n\n                \n}\n\n            \n});\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nUsing \nasync\n\n\nThe \nasync\n keyword will makes your function return a \nPromise\n under the hood. \nRead more about Async / Await\n.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nasync\n \nonLeave\n \n(\nclient\n)\n \n{\n\n        \nawait\n \ndoDatabaseOperation\n(\nclient\n);\n\n    \n}\n\n\n    \nasync\n \nonDispose\n \n()\n \n{\n\n        \nawait\n \nremoveRoomFromDatabase\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nProcess shutdown callback\n\n\nYou can also listen for process shutdown by setting a \nonShutdown\n callback.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nServer\n\n        \n\n    \n        \n\n            \nCluster Server\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nlet\n \nserver\n \n=\n \nnew\n \nServer\n();\n\n\n\nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\nmaster process is being shut down!\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n*\n \nas\n \ncluster\n \nfrom\n \ncluster\n;\n\n\nimport\n \n{\n \nClusterServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nlet\n \nserver\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n    \nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n        \nconsole\n.\nlog\n(\nmaster process is being shut down!\n);\n\n    \n});\n\n\n\n}\n \nelse\n \n{\n\n    \nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n        \nconsole\n.\nlog\n(\nworker process is being shut down!\n);\n\n    \n});\n\n\n}", 
            "title": "Graceful shutdown"
        }, 
        {
            "location": "/api-graceful-shutdown/#graceful-shutdown", 
            "text": "Colyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself:   Disconnect all connected clients asynchronously ( Room#onLeave )  Dispose all spawned rooms asynchronously ( Room#onDispose )  Perform optional asynchronous callback before shutting down the process ( Server#onShutdown  /  ClusterServer#onShutdown )   If you're performing async tasks on  onLeave  /  onDispose , you should return a  Promise , and resolve it when the task is ready. The same applies to  onShutdown(callback) .", 
            "title": "Graceful Shutdown"
        }, 
        {
            "location": "/api-graceful-shutdown/#returning-a-promise", 
            "text": "By returning a  Promise , the server will wait for them to be completed before killing the worker process.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n     onLeave   ( client )   { \n         return   new   Promise (( resolve ,   reject )   =   { \n             doDatabaseOperation (( err ,   data )   =   { \n                 if   ( err )   { \n                     reject ( err ); \n                 }   else   { \n                     resolve ( data ); \n                 } \n             }); \n         }); \n     } \n\n     onDispose   ()   { \n         return   new   Promise (( resolve ,   reject )   =   { \n             doDatabaseOperation (( err ,   data )   =   { \n                 if   ( err )   { \n                     reject ( err ); \n                 }   else   { \n                     resolve ( data ); \n                 } \n             }); \n         }); \n     }  }", 
            "title": "Returning a Promise"
        }, 
        {
            "location": "/api-graceful-shutdown/#using-async", 
            "text": "The  async  keyword will makes your function return a  Promise  under the hood.  Read more about Async / Await .  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n     async   onLeave   ( client )   { \n         await   doDatabaseOperation ( client ); \n     } \n\n     async   onDispose   ()   { \n         await   removeRoomFromDatabase (); \n     }  }", 
            "title": "Using async"
        }, 
        {
            "location": "/api-graceful-shutdown/#process-shutdown-callback", 
            "text": "You can also listen for process shutdown by setting a  onShutdown  callback.  \n                 \n                    \n         \n            \n         \n             Server \n         \n    \n         \n             Cluster Server \n         \n    \n         \n    \n         \n            \n         \n             import   {   Server   }   from   colyseus ;  let   server   =   new   Server ();  server . onShutdown ( function   ()   { \n     console . log ( master process is being shut down! );  });  \n\n         \n    \n         \n             import   *   as   cluster   from   cluster ;  import   {   ClusterServer   }   from   colyseus ;  let   server   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n     server . onShutdown ( function   ()   { \n         console . log ( master process is being shut down! ); \n     });  }   else   { \n     server . onShutdown ( function   ()   { \n         console . log ( worker process is being shut down! ); \n     });  }", 
            "title": "Process shutdown callback"
        }, 
        {
            "location": "/api-debugging/", 
            "text": "Debug messages\n\n\nInspector (\n--inspect\n flag)\n\n\n\n\nDebug messages\n\n\nThe server provides some debug messages that you can enable individually per category, by setting the \nDEBUG\n environment variable.\n\n\nTo enable all logs, you can run your server using:\n\n\nDEBUG=colyseus:* node server.js\n\n\n\n\n\nSee below all available debug categories with sample outputs.\n\n\ncolyseus:patch\n\n\nLogs the number of bytes and interval between patches broadcasted to all clients.\n\n\ncolyseus:patch \nchat\n (roomId: \nryWiL5rLTZ\n) is sending 28 bytes: +57ms\n\n\n\n\n\ncolyseus:patch:data\n\n\nDisplays a human-readable version of the data broadcasted to all clients.\n\n\ncolyseus:patch:data [ { op: \nreplace\n, path: \n/players/BygiLqrLpZ/x\n, value: 5 } ] +56ms\n\n\n\n\n\ncolyseus:cluster\n\n\nLogs when worker processes are spawned and re-spawned. \n\n\ncolyseus:cluster master spawned with pid 77216 +0ms\ncolyseus:cluster matchmaking spawned with pid 77217 +8ms\ncolyseus:cluster fork spawned with pid 77218 +7ms\ncolyseus:cluster fork spawned with pid 77219 +3ms\ncolyseus:cluster fork spawned with pid 77220 +3ms\ncolyseus:cluster fork spawned with pid 77221 +17ms\n\n\n\n\n\ncolyseus:matchmaking\n\n\nLogs the messages sent back and forth from master node to worker processes. You'll see them only if using \nClusterServer\n.\n\n\ncolyseus:matchmaking requesting CREATE_ROOM +54s\ncolyseus:matchmaking spawning \nchat\n on worker 77218 +52s\ncolyseus:matchmaking disposing \nchat\n on worker 77218 +2s\n\n\n\n\n\nInspector\n\n\nTo be able to use the \nbuilt-in inspector from Node.js\n\nyou'll need to use the \nServer\n class, which doesn't use inter-process communication. \n\n\nFor production, \nClusterServer\n is recommended, though.", 
            "title": "Debugging"
        }, 
        {
            "location": "/api-debugging/#debug-messages", 
            "text": "The server provides some debug messages that you can enable individually per category, by setting the  DEBUG  environment variable.  To enable all logs, you can run your server using:  DEBUG=colyseus:* node server.js  See below all available debug categories with sample outputs.", 
            "title": "Debug messages"
        }, 
        {
            "location": "/api-debugging/#colyseuspatch", 
            "text": "Logs the number of bytes and interval between patches broadcasted to all clients.  colyseus:patch  chat  (roomId:  ryWiL5rLTZ ) is sending 28 bytes: +57ms", 
            "title": "colyseus:patch"
        }, 
        {
            "location": "/api-debugging/#colyseuspatchdata", 
            "text": "Displays a human-readable version of the data broadcasted to all clients.  colyseus:patch:data [ { op:  replace , path:  /players/BygiLqrLpZ/x , value: 5 } ] +56ms", 
            "title": "colyseus:patch:data"
        }, 
        {
            "location": "/api-debugging/#colyseuscluster", 
            "text": "Logs when worker processes are spawned and re-spawned.   colyseus:cluster master spawned with pid 77216 +0ms\ncolyseus:cluster matchmaking spawned with pid 77217 +8ms\ncolyseus:cluster fork spawned with pid 77218 +7ms\ncolyseus:cluster fork spawned with pid 77219 +3ms\ncolyseus:cluster fork spawned with pid 77220 +3ms\ncolyseus:cluster fork spawned with pid 77221 +17ms", 
            "title": "colyseus:cluster"
        }, 
        {
            "location": "/api-debugging/#colyseusmatchmaking", 
            "text": "Logs the messages sent back and forth from master node to worker processes. You'll see them only if using  ClusterServer .  colyseus:matchmaking requesting CREATE_ROOM +54s\ncolyseus:matchmaking spawning  chat  on worker 77218 +52s\ncolyseus:matchmaking disposing  chat  on worker 77218 +2s", 
            "title": "colyseus:matchmaking"
        }, 
        {
            "location": "/api-debugging/#inspector", 
            "text": "To be able to use the  built-in inspector from Node.js \nyou'll need to use the  Server  class, which doesn't use inter-process communication.   For production,  ClusterServer  is recommended, though.", 
            "title": "Inspector"
        }, 
        {
            "location": "/client-overview/", 
            "text": "Overview", 
            "title": "Overview"
        }, 
        {
            "location": "/client-overview/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/client-state-synchronization/", 
            "text": "Whenever the \nstate mutates\n in the server-side, you can listen to particular variable changes in the client-side.\n\n\nThe \nRoom\n instance in the client-side uses \ndelta-listener\n to allow you to trigger callbacks for particular mutations.\n\n\nExample\n\n\nLet's say you have a list of entities and its positions in your server-side:\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonInit\n \n()\n \n{\n\n        \nthis\n.\nsetState\n({\n\n            \nentities\n:\n \n{\n\n                \nf98h3f\n:\n \n{\n \nx\n:\n \n0\n,\n \ny\n:\n \n0\n,\n \nhp\n:\n \n10\n \n},\n\n                \n24jgd3\n:\n \n{\n \nx\n:\n \n100\n,\n \ny\n:\n \n0\n,\n \nhp\n:\n \n6\n \n}\n\n            \n}\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn the client-side, you want to listen for mutations in the attributes of these entities. Before being able to catch them, we need to mutate them. The mutation can occur during your simulation interval, or by actions taken by connected clients (during \nonMessage\n in the server-side).\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonInit\n \n()\n \n{\n\n        \n// this.setState(...) see above\n\n        \nthis\n.\nsetSimulationInterval\n(()\n \n=\n \nthis\n.\nupdate\n());\n\n    \n}\n\n\n    \nupdate\n \n()\n \n{\n\n        \nfor\n \n(\nlet\n \nentityId\n \nin\n \nthis\n.\nstate\n.\nentities\n)\n \n{\n\n            \n// simple and naive gravity\n\n            \nthis\n.\nstate\n.\nentities\n[\nentityId\n].\ny\n \n+=\n \n1\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow that we have the mutations in place, we can listen to them in the client-side. The callback will be called for each attribute, of each entity.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nlisten\n(\nentities/:id/:attribute\n,\n \n(\nchange\n)\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\nchange\n.\noperation\n);\n \n// =\n \nreplace\n (can be \nadd\n, \nremove\n or \nreplace\n)\n\n    \nconsole\n.\nlog\n(\nchange\n.\npath\n[\nid\n]);\n \n// =\n \nf98h3f\n\n    \nconsole\n.\nlog\n(\nchange\n.\npath\n[\nattribute\n]);\n \n// =\n \ny\n\n    \nconsole\n.\nlog\n(\nchange\n.\nvalue\n);\n \n// =\n 1\n\n\n})\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nListen\n(\nentities/:id/:attribute\n,\n \nOnAttributeChange\n);\n\n\n\nvoid\n \nOnAttributeChange\n \n(\nDataChange\n \nchange\n)\n\n\n{\n\n    \nDebug\n.\nLog\n \n(\nOnAttributeChange\n);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\noperation\n);\n \n// =\n \nreplace\n (can be \nadd\n, \nremove\n or \nreplace\n)\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n \n// =\n \nf98h3f\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nattribute\n]);\n \n// =\n \ny\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\nvalue\n);\n \n// =\n 1\n\n\n})", 
            "title": "State synchronization"
        }, 
        {
            "location": "/deployment/", 
            "text": "Deploying on Heroku\n\n\nDeploying on Zeit Now\n\n\nDeploying on Nginx (recommended)\n\n\n\n\nHeroku\n\n\nYou can deploy the \ncolyseus-examples\n project on Heroku by gitting this button: \n\n\n\n\nNote:\n You can't use the \nClusterServer\n under Heroku's free tier. Only \nServer\n works on free tier, which doesn't use multiple processes.\n\n\nZeit Now\n\n\nYou can deploy the \ncolyseus-examples\n project on Zeit Now by gitting this button: \n\n\n\n\nNote:\n You can't use the \nClusterServer\n under Zeit Now's free tier. Only \nServer\n works on free tier, which doesn't use multiple processes.\n\n\nNginx (recommended)\n\n\nIt's recommended to use \nforever\n and \nnginx\n in your production environment.\n\n\nForever\n\n\nInstall \nforever\n in your environment.\n\n\nnpm install -g forever\n\n\n\n\n\nThen start your game server using it:\n\n\nforever your-server.js\n\n\n\n\n\nNginx configuration\n\n\nserver {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \nupgrade\n;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}\n\n\n\n\n\nNginx configuration with SSL\n\n\nIt's recommended to acquire your certificate from \nLetsEncrypt\n.\n\n\nserver {\n    listen 80;\n    listen 443 ssl;\n    server_name yourdomain.com;\n\n    ssl_certificate /path/to/your/cert.crt;\n    ssl_certificate_key /path/to/your/cert.key;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \nupgrade\n;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Deployment"
        }, 
        {
            "location": "/deployment/#heroku", 
            "text": "You can deploy the  colyseus-examples  project on Heroku by gitting this button:    Note:  You can't use the  ClusterServer  under Heroku's free tier. Only  Server  works on free tier, which doesn't use multiple processes.", 
            "title": "Heroku"
        }, 
        {
            "location": "/deployment/#zeit-now", 
            "text": "You can deploy the  colyseus-examples  project on Zeit Now by gitting this button:    Note:  You can't use the  ClusterServer  under Zeit Now's free tier. Only  Server  works on free tier, which doesn't use multiple processes.", 
            "title": "Zeit Now"
        }, 
        {
            "location": "/deployment/#nginx-recommended", 
            "text": "It's recommended to use  forever  and  nginx  in your production environment.", 
            "title": "Nginx (recommended)"
        }, 
        {
            "location": "/deployment/#forever", 
            "text": "Install  forever  in your environment.  npm install -g forever  Then start your game server using it:  forever your-server.js", 
            "title": "Forever"
        }, 
        {
            "location": "/deployment/#nginx-configuration", 
            "text": "server {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection  upgrade ;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Nginx configuration"
        }, 
        {
            "location": "/deployment/#nginx-configuration-with-ssl", 
            "text": "It's recommended to acquire your certificate from  LetsEncrypt .  server {\n    listen 80;\n    listen 443 ssl;\n    server_name yourdomain.com;\n\n    ssl_certificate /path/to/your/cert.crt;\n    ssl_certificate_key /path/to/your/cert.key;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection  upgrade ;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Nginx configuration with SSL"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\nHow would I broadcast data from one client to others?\n\n\nYou usually don't do that. By using an authoritative game server, the clients generally send \nactions\n to the server, and the server \nmutates\n the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval.\n\n\nDo I need client-prediction in my game? Does Colyseus help me with this?\n\n\nColyseus does not provide any client-prediction solution out of the box. Games such as \nwilds.io\n and \ncrashracing.com\n do not use any form of client-prediction. \nlerp\ning user coordinates usually gives reasonable results.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#how-would-i-broadcast-data-from-one-client-to-others", 
            "text": "You usually don't do that. By using an authoritative game server, the clients generally send  actions  to the server, and the server  mutates  the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval.", 
            "title": "How would I broadcast data from one client to others?"
        }, 
        {
            "location": "/faq/#do-i-need-client-prediction-in-my-game-does-colyseus-help-me-with-this", 
            "text": "Colyseus does not provide any client-prediction solution out of the box. Games such as  wilds.io  and  crashracing.com  do not use any form of client-prediction.  lerp ing user coordinates usually gives reasonable results.", 
            "title": "Do I need client-prediction in my game? Does Colyseus help me with this?"
        }, 
        {
            "location": "/architecture/", 
            "text": "Architecture\n\n\nState sync / Binary patches\n\n\nWhen connected to a Room, all the clients should have access to the full state available from the server. Here's how it works:\n\n\n\n\nUpon the first connection, the client receives the latest encoded room state (\nmsgpack format\n).\n\n\nAt the \npatchRate\n interval (default: 50ms), the server will encode the whole room state again. If it differs from the latest encoded state, the delta (\nfossil's delta\n) between the latest state and the new state is calculated and sent to all connected clients.\n\n\nWhen the client receives the delta, it is applied against the latest encoded state (the result of the last applied patch), and then decoded.", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#architecture", 
            "text": "", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#state-sync-binary-patches", 
            "text": "When connected to a Room, all the clients should have access to the full state available from the server. Here's how it works:   Upon the first connection, the client receives the latest encoded room state ( msgpack format ).  At the  patchRate  interval (default: 50ms), the server will encode the whole room state again. If it differs from the latest encoded state, the delta ( fossil's delta ) between the latest state and the new state is calculated and sent to all connected clients.  When the client receives the delta, it is applied against the latest encoded state (the result of the last applied patch), and then decoded.", 
            "title": "State sync / Binary patches"
        }, 
        {
            "location": "/roadmap/", 
            "text": "Overview:\n\n\n\n\n~~Support vertical scalability (\n#43\n)~~ - \u2714\n\n\n~~Standardize how to authenticate users in a secure way. (\n#49\n, suggested by \n@darkyen\n)~~ - \u2714\n\n\nSupport for splitting and filtering views (\n#59\n, suggested by \n@darkyen\n and the whole \ngitter channel\n!)\n\n\nSupport serialization methods other than Fossil's Delta algorithm. (\n#58\n, suggested by \n@derwish-pro\n)\n\n\nPM2 support (\n#56\n)\n\n\nSupport horizontal scalability. (\n#57\n)\n\n\nSupport transport layers other than WebSocket. (\n#48\n, suggested by \n@darkyen\n)\n\n\n\n\nIn order to achieve these goals, it would be great to split Colyseus's internal parts as composable modules. Specially match-making, which is the most complex feature to deal with by having multiple servers/processes running.", 
            "title": "Roadmap"
        }, 
        {
            "location": "/roadmap/#overview", 
            "text": "~~Support vertical scalability ( #43 )~~ - \u2714  ~~Standardize how to authenticate users in a secure way. ( #49 , suggested by  @darkyen )~~ - \u2714  Support for splitting and filtering views ( #59 , suggested by  @darkyen  and the whole  gitter channel !)  Support serialization methods other than Fossil's Delta algorithm. ( #58 , suggested by  @derwish-pro )  PM2 support ( #56 )  Support horizontal scalability. ( #57 )  Support transport layers other than WebSocket. ( #48 , suggested by  @darkyen )   In order to achieve these goals, it would be great to split Colyseus's internal parts as composable modules. Specially match-making, which is the most complex feature to deal with by having multiple servers/processes running.", 
            "title": "Overview:"
        }
    ]
}