{
    "docs": [
        {
            "location": "/", 
            "text": "Colyseus is a Authoritative Multiplayer Game Server for Node.js. It allows you to focus on your gameplay instead of bothering about networking.\n\n\nThe mission of this framework is to be the easiest solution for creating your\nown multiplayer games in JavaScript. \n\n\nThis framework is fairly new and is being evolved constantly. You're encouraged to take a look on \nsome games being developed with it\n and make your own!\n\n\nWhat Colyseus provides to you:\n\n\n\n\nWebSocket-based communication\n\n\nSimple API in the server-side and client-side.\n\n\nAutomatic state synchronization between server and client.\n\n\nMatchmaking clients into game sessions\n\n\nScale on many processes on a single machine.\n\n\n\n\nWhat Colyseus won't provide:\n\n\n\n\nGame Engine: Colyseus is agnostic of the engine you're using. Need Physics? Add your own logic / package.\n\n\nDatabase: It's up to configure and select which database you'd like to use.\n\n\n\n\nWhat people are saying about it?\n\n\n\n\n@bmovement\n\n\n\"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\"\n\n\n\n\n\n\n@sagestudios\n\n\nLoved the framework. Exactly what we are looking for in terms of features.\n\n\n\n\nExternal links\n\n\n\n\n\ud83c\udf10 \n Website\n\n\n\ud83d\udcac \n Forum\n\n\n\ud83d\udcb0 \n Support the project", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-colyseus-provides-to-you", 
            "text": "WebSocket-based communication  Simple API in the server-side and client-side.  Automatic state synchronization between server and client.  Matchmaking clients into game sessions  Scale on many processes on a single machine.", 
            "title": "What Colyseus provides to you:"
        }, 
        {
            "location": "/#what-colyseus-wont-provide", 
            "text": "Game Engine: Colyseus is agnostic of the engine you're using. Need Physics? Add your own logic / package.  Database: It's up to configure and select which database you'd like to use.", 
            "title": "What Colyseus won't provide:"
        }, 
        {
            "location": "/#what-people-are-saying-about-it", 
            "text": "@bmovement  \"Thanks again for this framework... it allowed someone like me who just wants the server to be a black box to focus on my game instead of getting bogged down learning a whole new skill set!\"    @sagestudios  Loved the framework. Exactly what we are looking for in terms of features.", 
            "title": "What people are saying about it?"
        }, 
        {
            "location": "/#external-links", 
            "text": "\ud83c\udf10   Website  \ud83d\udcac   Forum  \ud83d\udcb0   Support the project", 
            "title": "External links"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started\n\n\nRecommended NodeJS packages for games\n\n\nThese modules can be useful while developing games on both NodeJS and the Browser.\n\n\n\n\n@gamestdio/mathf\n - Mathematical functions, borrowed from Unity3D's API\n\n\n@gamestdio/timer\n - Reliable timing events \n\n\n@gamestdio/keycode\n - Constants for keyboard key codes (\nevent.which\n)\n\n\n\n\nThese modules can be used only in the browser:\n\n\n\n\n@gamestdio/pixi-engine", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#recommended-nodejs-packages-for-games", 
            "text": "These modules can be useful while developing games on both NodeJS and the Browser.   @gamestdio/mathf  - Mathematical functions, borrowed from Unity3D's API  @gamestdio/timer  - Reliable timing events   @gamestdio/keycode  - Constants for keyboard key codes ( event.which )   These modules can be used only in the browser:   @gamestdio/pixi-engine", 
            "title": "Recommended NodeJS packages for games"
        }, 
        {
            "location": "/concept-state-synchronization/", 
            "text": "", 
            "title": "State synchronization"
        }, 
        {
            "location": "/concept-matchmaking/", 
            "text": "", 
            "title": "Matchmaking"
        }, 
        {
            "location": "/concept-worker-processes/", 
            "text": "Worker processes\n\n\nClustered environment\n\n\nThe clustered environment is recommended for your production environment. To leverage from it, you'll need to use \nClusterServer\n class. \n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \ncluster\n \nfrom\n \ncluster\n;\n\n\nimport\n \n*\n \nas\n \npath\n \nfrom\n \npath\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\n\nimport\n \n{\n \nClusterServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \nChatRoom\n \n}\n \nfrom\n \n./ChatRoom\n;\n\n\n\nconst\n \nPORT\n \n=\n \n8080\n;\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n  \ngameServer\n.\nlisten\n(\nPORT\n);\n\n  \ngameServer\n.\nfork\n();\n\n\n\n}\n \nelse\n \n{\n\n  \nconst\n \napp\n \n=\n \nnew\n \nexpress\n();\n\n\n  \n// Register ChatRoom as \nchat\n\n  \ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n);\n\n\n  \n// Create HTTP Server\n\n  \ngameServer\n.\nattach\n({\n \nserver\n: \napp\n \n});\n\n\n}\n\n\n\nconsole\n.\nlog\n(\n`Listening on \n${\n \nPORT\n \n}\n`\n);\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \ncluster\n \n=\n \nrequire\n(\ncluster\n);\n\n\nconst\n \npath\n \n=\n \nrequire\n(\npath\n);\n\n\nconst\n \nexpress\n \n=\n \nrequire\n(\nexpress\n);\n\n\n\nconst\n \nClusterServer\n \n=\n \nrequire\n(\ncolyseus\n).\nClusterServer\n;\n\n\nconst\n \nChatRoom\n \n=\n \nrequire\n(\n./ChatRoom\n).\nChatRoom\n;\n\n\n\nconst\n \nPORT\n \n=\n \n8080\n;\n\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n  \ngameServer\n.\nlisten\n(\nPORT\n);\n\n  \ngameServer\n.\nfork\n();\n\n\n\n}\n \nelse\n \n{\n\n  \nconst\n \napp\n \n=\n \nnew\n \nexpress\n();\n\n\n  \n// Register ChatRoom as \nchat\n\n  \ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n);\n\n\n  \n// Create HTTP Server\n\n  \ngameServer\n.\nattach\n({\n \nserver\n: \napp\n \n});\n\n\n}\n\n\n\nconsole\n.\nlog\n(\n`Listening on \n${\n \nPORT\n \n}\n`\n);\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nBy default, \nClusterServer\n spawn a worker process for each CPU available on the host machine.\n\n\n                +----------------+                                                      \n                | Master process |                                                      \n                +--------|-------+                                                      \n                         |                                                              \n              +----------+-----------+                                                  \n              | Match-making process |                                                  \n              +----------------------+                                                  \n                         |                                                              \n         +----------------                                                              \n         |                                                                              \n+--------|-------+----------------+----------------+                                    \n| Worker process | Worker process | Worker process |                                    \n+----------------+----------------+----------------+                                    \n  # FooRoom        # FooRoom        # QuxRoom                                           \n  # BarRoom                \n\n\n\n\n\nMaster process\n\n\nThe master process will handle redirecting the WebSocket connection to the suitable process. When not connected to a room, the Match-making process will be selected for that connection.\n\n\nMatch-making process\n\n\nThe Match-making process is responsible for responding to requests for joining a room/session. After the request has been completed, the client will establish a new WebSocket connection which will be redirected the Worker process that room is living in.\n\n\nWorker process\n\n\nEach Worker processes can handle multiple rooms / sessions.\n\n\nSingle process environment\n\n\nThe single process environment is lightweight and is best for local development and prototyping. You can deploy it on \nZeit Now\n or \nHeroku\n for free.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nTypeScript\n\n        \n\n    \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n*\n \nas\n \nhttp\n \nfrom\n \nhttp\n;\n\n\nimport\n \n*\n \nas\n \nexpress\n \nfrom\n \nexpress\n;\n\n\n\nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\nimport\n \n{\n \nChatRoom\n \n}\n \nfrom\n \n./ChatRoom\n;\n\n\n\nconst\n \nport\n \n=\n \n8080\n;\n\n\nconst\n \nendpoint\n \n=\n \nlocalhost\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\n\n// Create HTTP \n WebSocket servers\n\n\nconst\n \nserver\n \n=\n \nhttp\n.\ncreateServer\n(\napp\n);\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n \nserver\n: \nserver\n \n});\n\n\n\n// Register ChatRoom as \nchat\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n);\n\n\ngameServer\n.\nlisten\n(\nport\n);\n\n\n\nconsole\n.\nlog\n(\n`Listening on http://\n${\n \nendpoint\n \n}\n:\n${\n \nport\n \n}\n`\n)\n\n\n\n\n        \n\n    \n        \n\n            \nconst\n \nhttp\n \n=\n \nrequire\n(\nhttp\n);\n\n\nconst\n \nexpress\n \n=\n \nrequire\n(\nexpress\n);\n\n\n\nconst\n \nServer\n \n=\n \nrequire\n(\ncolyseus\n).\nServer\n;\n\n\nconst\n \nChatRoom\n \n=\n \nrequire\n(\n./ChatRoom\n).\nChatRoom\n;\n\n\n\nconst\n \nport\n \n=\n \n8080\n;\n\n\nconst\n \nendpoint\n \n=\n \nlocalhost\n;\n\n\n\nconst\n \napp\n \n=\n \nexpress\n();\n\n\n\n// Create HTTP \n WebSocket servers\n\n\nconst\n \nserver\n \n=\n \nhttp\n.\ncreateServer\n(\napp\n);\n\n\nconst\n \ngameServer\n \n=\n \nnew\n \nServer\n({\n \nserver\n: \nserver\n \n});\n\n\n\n// Register ChatRoom as \nchat\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n);\n\n\ngameServer\n.\nlisten\n(\nport\n);\n\n\n\nconsole\n.\nlog\n(\n`Listening on http://\n${\n \nendpoint\n \n}\n:\n${\n \nport\n \n}\n`\n)", 
            "title": "Worker processes"
        }, 
        {
            "location": "/concept-worker-processes/#worker-processes", 
            "text": "", 
            "title": "Worker processes"
        }, 
        {
            "location": "/concept-worker-processes/#clustered-environment", 
            "text": "The clustered environment is recommended for your production environment. To leverage from it, you'll need to use  ClusterServer  class.   \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   cluster   from   cluster ;  import   *   as   path   from   path ;  import   *   as   express   from   express ;  import   {   ClusterServer   }   from   colyseus ;  import   {   ChatRoom   }   from   ./ChatRoom ;  const   PORT   =   8080 ;  const   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n   gameServer . listen ( PORT ); \n   gameServer . fork ();  }   else   { \n   const   app   =   new   express (); \n\n   // Register ChatRoom as  chat \n   gameServer . register ( chat ,   ChatRoom ); \n\n   // Create HTTP Server \n   gameServer . attach ({   server :  app   });  }  console . log ( `Listening on  ${   PORT   } ` );  \n\n         \n    \n         \n             const   cluster   =   require ( cluster );  const   path   =   require ( path );  const   express   =   require ( express );  const   ClusterServer   =   require ( colyseus ). ClusterServer ;  const   ChatRoom   =   require ( ./ChatRoom ). ChatRoom ;  const   PORT   =   8080 ;  const   gameServer   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n   gameServer . listen ( PORT ); \n   gameServer . fork ();  }   else   { \n   const   app   =   new   express (); \n\n   // Register ChatRoom as  chat \n   gameServer . register ( chat ,   ChatRoom ); \n\n   // Create HTTP Server \n   gameServer . attach ({   server :  app   });  }  console . log ( `Listening on  ${   PORT   } ` );  \n\n         \n    \n         \n    \n                 \n                      By default,  ClusterServer  spawn a worker process for each CPU available on the host machine.                  +----------------+                                                      \n                | Master process |                                                      \n                +--------|-------+                                                      \n                         |                                                              \n              +----------+-----------+                                                  \n              | Match-making process |                                                  \n              +----------------------+                                                  \n                         |                                                              \n         +----------------                                                              \n         |                                                                              \n+--------|-------+----------------+----------------+                                    \n| Worker process | Worker process | Worker process |                                    \n+----------------+----------------+----------------+                                    \n  # FooRoom        # FooRoom        # QuxRoom                                           \n  # BarRoom", 
            "title": "Clustered environment"
        }, 
        {
            "location": "/concept-worker-processes/#master-process", 
            "text": "The master process will handle redirecting the WebSocket connection to the suitable process. When not connected to a room, the Match-making process will be selected for that connection.", 
            "title": "Master process"
        }, 
        {
            "location": "/concept-worker-processes/#match-making-process", 
            "text": "The Match-making process is responsible for responding to requests for joining a room/session. After the request has been completed, the client will establish a new WebSocket connection which will be redirected the Worker process that room is living in.", 
            "title": "Match-making process"
        }, 
        {
            "location": "/concept-worker-processes/#worker-process", 
            "text": "Each Worker processes can handle multiple rooms / sessions.", 
            "title": "Worker process"
        }, 
        {
            "location": "/concept-worker-processes/#single-process-environment", 
            "text": "The single process environment is lightweight and is best for local development and prototyping. You can deploy it on  Zeit Now  or  Heroku  for free.  \n                 \n                    \n         \n            \n         \n             TypeScript \n         \n    \n         \n             JavaScript \n         \n    \n         \n    \n         \n            \n         \n             import   *   as   http   from   http ;  import   *   as   express   from   express ;  import   {   Server   }   from   colyseus ;  import   {   ChatRoom   }   from   ./ChatRoom ;  const   port   =   8080 ;  const   endpoint   =   localhost ;  const   app   =   express ();  // Create HTTP   WebSocket servers  const   server   =   http . createServer ( app );  const   gameServer   =   new   Server ({   server :  server   });  // Register ChatRoom as  chat  gameServer . register ( chat ,   ChatRoom );  gameServer . listen ( port );  console . log ( `Listening on http:// ${   endpoint   } : ${   port   } ` )  \n\n         \n    \n         \n             const   http   =   require ( http );  const   express   =   require ( express );  const   Server   =   require ( colyseus ). Server ;  const   ChatRoom   =   require ( ./ChatRoom ). ChatRoom ;  const   port   =   8080 ;  const   endpoint   =   localhost ;  const   app   =   express ();  // Create HTTP   WebSocket servers  const   server   =   http . createServer ( app );  const   gameServer   =   new   Server ({   server :  server   });  // Register ChatRoom as  chat  gameServer . register ( chat ,   ChatRoom );  gameServer . listen ( port );  console . log ( `Listening on http:// ${   endpoint   } : ${   port   } ` )", 
            "title": "Single process environment"
        }, 
        {
            "location": "/api-room/", 
            "text": "Room API\n\n\nAbstract methods\n\n\nRoom handlers should implement these methods.\n\n\n\n\nonInit (options)\n - When room is initialized\n\n\nrequestJoin (options)\n - Checks if a new client is allowed to join. (default: \nreturn true\n)\n\n\nonJoin (client)\n - When client successfully join the room\n\n\nonLeave (client)\n - When a client leaves the room\n\n\nonMessage (client, data)\n - When a client sends a message\n\n\nonDispose ()\n - Cleanup callback, called after there are no more clients in the room. (see \nautoDispose\n)\n\n\n\n\nPublic properties\n\n\n\n\npatchRate\n - Frequency to send the room state to connected clients (in milliseconds)\n\n\nmaxClients\n - Maximum number of clients allowed to connect into the room\n\n\nautoDispose\n - Automatically dispose the room when last client disconnect. (default: \ntrue\n)\n\n\nclock\n - A \nClockTimer\n instance\n\n\nclients\n - Array of connected clients\n\n\ntimeline\n - A \nTimeline\n instance (see \nuseTimeline\n)\n\n\n\n\nPublic methods:\n\n\nRoom handlers have these methods available.\n\n\n\n\nsetState( object )\n - Set the current state to be broadcasted / patched.\n\n\nsetSimulationInterval( callback[, milliseconds=16.6] )\n - (Optional) Create the simulation interval that will change the state of the game. Default simulation interval: 16.6ms (60fps)\n\n\nsetPatchRate( milliseconds )\n - Set frequency the patched state should be sent to all clients. (default: \n50\n = 20fps)\n\n\nsend( client, data )\n - Send data to a particular client\n\n\nlock()\n - Prevent new clients from joining the room\n\n\nunlock()\n - Unlock the room for new clients\n\n\nbroadcast( data )\n - Send data to all connected clients\n\n\ndisconnect()\n - Disconnect all clients, then dispose\n\n\nuseTimeline([ maxSnapshots=10 ])\n - (Optional, experimental) Keep state snapshots for lag compensation", 
            "title": "Room API"
        }, 
        {
            "location": "/api-room/#room-api", 
            "text": "", 
            "title": "Room API"
        }, 
        {
            "location": "/api-room/#abstract-methods", 
            "text": "Room handlers should implement these methods.   onInit (options)  - When room is initialized  requestJoin (options)  - Checks if a new client is allowed to join. (default:  return true )  onJoin (client)  - When client successfully join the room  onLeave (client)  - When a client leaves the room  onMessage (client, data)  - When a client sends a message  onDispose ()  - Cleanup callback, called after there are no more clients in the room. (see  autoDispose )", 
            "title": "Abstract methods"
        }, 
        {
            "location": "/api-room/#public-properties", 
            "text": "patchRate  - Frequency to send the room state to connected clients (in milliseconds)  maxClients  - Maximum number of clients allowed to connect into the room  autoDispose  - Automatically dispose the room when last client disconnect. (default:  true )  clock  - A  ClockTimer  instance  clients  - Array of connected clients  timeline  - A  Timeline  instance (see  useTimeline )", 
            "title": "Public properties"
        }, 
        {
            "location": "/api-room/#public-methods", 
            "text": "Room handlers have these methods available.   setState( object )  - Set the current state to be broadcasted / patched.  setSimulationInterval( callback[, milliseconds=16.6] )  - (Optional) Create the simulation interval that will change the state of the game. Default simulation interval: 16.6ms (60fps)  setPatchRate( milliseconds )  - Set frequency the patched state should be sent to all clients. (default:  50  = 20fps)  send( client, data )  - Send data to a particular client  lock()  - Prevent new clients from joining the room  unlock()  - Unlock the room for new clients  broadcast( data )  - Send data to all connected clients  disconnect()  - Disconnect all clients, then dispose  useTimeline([ maxSnapshots=10 ])  - (Optional, experimental) Keep state snapshots for lag compensation", 
            "title": "Public methods:"
        }, 
        {
            "location": "/api-room-handlers/", 
            "text": "You can register as many custom room handlers as you want on the server.\n\n\nWhen creating a room class, you'll need to implement its \nbasic API\n in order to change its state to deal with your game, such as:\n\n\n\n\nrequestJoin (options)\n\n\nonJoin (client, options)\n\n\nonLeave (client)\n\n\nonMessage (client, data)\n\n\n\n\nvar\n \nRoom\n \n=\n \nrequire\n(\ncolyseus\n).\nRoom\n\n\n\nclass\n \nChatRoom\n \nextends\n \nRoom\n \n{\n\n\n  \nonInit\n \n(\noptions\n)\n \n{\n\n    \n// initialize room\n\n  \n}\n\n\n  \nonJoin\n \n(\nclient\n,\n \noptions\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nclient\n.\nid\n,\n \njoined!\n)\n\n  \n}\n\n\n  \nonLeave\n \n(\nclient\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nclient\n.\nid\n,\n \nleft!\n)\n\n  \n}\n\n\n  \nonMessage\n \n(\nclient\n,\n \ndata\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nclient\n.\nid\n,\n \nsent\n,\n \ndata\n)\n\n  \n}\n\n\n}\n\n\n\nmodule\n.\nexports\n \n=\n \nChatRoom\n\n\n\n\n\n\nRegistering the room handler\n\n\nConsidering you have a \ncolyseus.Server\n or \ncolyseus.ClusterServer\n instance in your \nindex.js\n file (\nas in the example project\n), you'll need to specify a unique identifier for your room handler upon registration.\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n);\n\n\n\n\n\n\nYou can register the same room class multiple times, by using different identifiers. Use the third argument to set custom \nonInit()\n options.\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n);\n\n\ngameServer\n.\nregister\n(\nchat_with_more_players\n,\n \nChatRoom\n,\n \n{\n\n  \nmaxClients\n:\n \n20\n\n\n})\n\n\n\n\n\n\nIn this example, we're going to limit the maximum clients allowed on rooms called \n'chat_room_with_more_players'\n to \n20\n. In order to make this \nmaxClients\n option work as expected, we'll need to implement the \nrequestJoin\n method:\n\n\nclass\n \nChatRoom\n \nextends\n \nRoom\n \n{\n\n  \nonInit\n \n(\noptions\n)\n \n{\n\n    \nthis\n.\noptions\n \n=\n \noptions\n;\n\n  \n}\n\n\n  \n// ...\n\n  \nrequestJoin\n(\noptions\n)\n \n{\n\n    \nreturn\n \nthis\n.\nclients\n.\nlength\n \n \nthis\n.\noptions\n.\nmaxClients\n;\n\n  \n}\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\nListening to room events outside the room scope\n\n\nYou can listen to room events per registered room handler, outside the room scope, by listening to these events:\n\n\n\n\n\"create\"\n - when room has been created\n\n\n\"dispose\"\n - when room has been disposed\n\n\n\"join\"\n - when a client join the room\n\n\n\"leave\"\n - when a client leave the room\n\n\n\"lock\"\n - when room has been locked\n\n\n\"unlock\"\n - when room has been unlocked\n\n\n\n\nExample:\n\n\ngameServer\n.\nregister\n(\nchat\n,\n \nChatRoom\n).\n\n  \non\n(\ncreate\n,\n \n(\nroom\n)\n \n=\n \nconsole\n.\nlog\n(\nroom created:\n,\n \nroom\n.\nroomId\n)).\n\n  \non\n(\ndispose\n,\n \n(\nroom\n)\n \n=\n \nconsole\n.\nlog\n(\nroom disposed:\n,\n \nroom\n.\nroomId\n)).\n\n  \non\n(\njoin\n,\n \n(\nroom\n,\n \nclient\n)\n \n=\n \nconsole\n.\nlog\n(\nclient\n.\nid\n,\n \njoined\n,\n \nroom\n.\nroomId\n)).\n\n  \non\n(\nleave\n,\n \n(\nroom\n,\n \nclient\n)\n \n=\n \nconsole\n.\nlog\n(\nclient\n.\nid\n,\n \nleft\n,\n \nroom\n.\nroomId\n));\n\n\n\n\n\n\nNote:\n It's completely discouraged to use these methods to manipulate room state. Implement the \nabstract methods\n in your room class instead.", 
            "title": "Room handlers"
        }, 
        {
            "location": "/api-room-handlers/#registering-the-room-handler", 
            "text": "Considering you have a  colyseus.Server  or  colyseus.ClusterServer  instance in your  index.js  file ( as in the example project ), you'll need to specify a unique identifier for your room handler upon registration.  gameServer . register ( chat ,   ChatRoom );   You can register the same room class multiple times, by using different identifiers. Use the third argument to set custom  onInit()  options.  gameServer . register ( chat ,   ChatRoom );  gameServer . register ( chat_with_more_players ,   ChatRoom ,   { \n   maxClients :   20  })   In this example, we're going to limit the maximum clients allowed on rooms called  'chat_room_with_more_players'  to  20 . In order to make this  maxClients  option work as expected, we'll need to implement the  requestJoin  method:  class   ChatRoom   extends   Room   { \n   onInit   ( options )   { \n     this . options   =   options ; \n   } \n\n   // ... \n   requestJoin ( options )   { \n     return   this . clients . length     this . options . maxClients ; \n   } \n   // ...  }", 
            "title": "Registering the room handler"
        }, 
        {
            "location": "/api-room-handlers/#listening-to-room-events-outside-the-room-scope", 
            "text": "You can listen to room events per registered room handler, outside the room scope, by listening to these events:   \"create\"  - when room has been created  \"dispose\"  - when room has been disposed  \"join\"  - when a client join the room  \"leave\"  - when a client leave the room  \"lock\"  - when room has been locked  \"unlock\"  - when room has been unlocked   Example:  gameServer . register ( chat ,   ChatRoom ). \n   on ( create ,   ( room )   =   console . log ( room created: ,   room . roomId )). \n   on ( dispose ,   ( room )   =   console . log ( room disposed: ,   room . roomId )). \n   on ( join ,   ( room ,   client )   =   console . log ( client . id ,   joined ,   room . roomId )). \n   on ( leave ,   ( room ,   client )   =   console . log ( client . id ,   left ,   room . roomId ));   Note:  It's completely discouraged to use these methods to manipulate room state. Implement the  abstract methods  in your room class instead.", 
            "title": "Listening to room events outside the room scope"
        }, 
        {
            "location": "/api-room-state/", 
            "text": "The room handlers are stateful in Colyseus. Each room holds its own state. The server automatically broadcasts the changes (patched state) to all connected clients in a configurable interval.\n\n\nRoom state diagram:\n\n\n              room.send({ action: \nleft\n })                             \n\n                           |                                            \n      +------------+       |       +-----------------------------------+\n+-----| Client #1  --------|       |  Room handler #1                  |\n|     +------------+       |       |                                   |\n|     +------------+       |       |  onMessage (client, data) {       |\n|------ Client #2  |       --------+    if (data.action === \nleft\n) {  |\n|     +------------+               |      // update the room state     |\n|     +------------+               |    }                              |\n|------ Client #3  |               |  }                                |\n|     +------------+               +-----------------------------------+\n|                                                    |                  \n|        patch state broadcast (binary diff)         |                  \n|----------------------------------------------------+\n\n\n\n\n\nThere are two ways of dealing with the room state: using plain JavaScript objects, or having a state handler class.\n\n\nPlain Object State\n\n\nThe simplest way to deal with the room state is using a plain JavaScript object.\n\n\nclass\n \nChatRoom\n \nextends\n \nRoom\n \n{\n\n  \nconstructor\n(\noptions\n)\n \n{\n\n    \nsuper\n(\noptions\n)\n\n\n    \n// broadcast patched state every 1 second\n\n    \nthis\n.\nsetPatchRate\n(\n \n1000\n \n)\n\n\n    \n// use a plain object state, holding the room \nmessages\n.\n\n    \nthis\n.\nsetState\n({\n\n      \nmessages\n:\n \n[]\n\n    \n})\n\n  \n}\n\n\n  \nonMessage\n \n(\nclient\n,\n \ndata\n)\n \n{\n\n    \nthis\n.\nstate\n.\nmessages\n.\npush\n(\ndata\n.\nmessage\n)\n\n  \n}\n\n\n}\n\n\n\n\n\n\nState Handler Class\n\n\nEven though you can use plain objects to define the state directly in the room handler, the recommended way is to define your own data structures for it, and methods to manipulate the state inside these data structures.\n\n\nYou can use the \n@nosync\n decorator to define data that won't be synched with the clients (non-enumerable).\n\n\nimport\n \n{\n \nnosync\n,\n \nEntityMap\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nexport\n \nclass\n \nStateHandler\n \n{\n\n  \nplayers\n: \nany\n \n=\n \n{};\n\n\n  \n@nosync\n \nmapBuilder\n \n=\n  \nnew\n \nMapBuilder\n();\n\n\n  \nconstructor\n \n()\n \n{\n\n    \nthis\n.\nplayers\n \n=\n \n{};\n\n    \nthis\n.\nmap\n \n=\n \nthis\n.\nmapBuilder\n.\nbuild\n();\n\n  \n}\n\n\n  \nrestart\n \n()\n \n{\n\n    \nthis\n.\nmap\n \n=\n \nthis\n.\nmapBuilder\n.\nbuild\n();\n\n  \n}\n\n\n  \naddPlayer\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nplayers\n[\n \nclient\n.\nid\n \n]\n \n=\n \n{};\n\n  \n}\n\n\n  \nremovePlayer\n \n(\nclient\n)\n \n{\n\n    \ndelete\n \nthis\n.\nplayers\n[\n \nclient\n.\nid\n \n];\n\n  \n}\n\n\n\n}\n\n\n\n\n\n\nOn this example, the \nStateHandler\n creates a \nMapBuilder\n instance (that won't be visible in the client-side), which would be responsible for creating the map data. It exposes some methods to be called from the parent \nRoom\n instance, such as \naddPlayer\n and \nrestart\n.\n\n\nTo use this \nStateHandler\n class in a \nRoom\n instance it would look like this:\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n\n\nimport\n \n{\n \nStateHandler\n \n}\n \nfrom\n \n./StateHandler\n;\n\n\n\nexport\n \nclass\n \nMapRoom\n \nextends\n \nRoom\nStateHandler\n \n{\n\n  \nonInit\n \n(\noptions\n)\n \n{\n\n\n    \n// sync state every 50ms\n\n    \nthis\n.\nsetPatchRate\n(\n \n1000\n \n/\n \n20\n \n);\n\n\n    \n// initialize StateHandler\n\n    \nthis\n.\nsetState\n(\n \nnew\n \nStateHandler\n()\n \n);\n\n\n    \n// reset the state every 3 minutes\n\n    \nsetInterval\n(()\n \n=\n \nthis\n.\nstate\n.\nrestart\n(),\n \n1000\n \n*\n \n60\n \n*\n \n3\n);\n\n  \n}\n\n\n  \nonJoin\n \n(\nclient\n)\n \n{\n\n    \n// add player instance to room state\n\n    \nthis\n.\nstate\n.\naddPlayer\n(\nclient\n);\n\n  \n}\n\n\n  \nonLeave\n \n(\nclient\n)\n \n{\n\n    \n// add player instance to room state\n\n    \nthis\n.\nstate\n.\nremovePlayer\n(\nclient\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nYou can go on and define more data structures for any kind of object you need. Let's define the \nPlayer\n now.\n\n\nexport\n \nclass\n \nPlayer\n \n{\n\n  \nlife\n: \nnumber\n \n=\n \n50\n;\n\n  \nmaxLife\n: \nnumber\n \n=\n \n50\n;\n\n  \ndamage\n: \nnumber\n \n=\n \n9\n;\n\n\n  \nconstructor\n \n()\n \n{\n\n    \n// recovers a life a little every 2 seconds\n\n    \nsetInterval\n(()\n \n=\n \nthis\n.\nrecoverLife\n(),\n \n2000\n);\n\n  \n}\n\n\n  \nrecoverLife\n \n()\n \n{\n\n    \nif\n \n(\nthis\n.\nlife\n \n \nthis\n.\nmaxLife\n)\n \n{\n\n      \nthis\n.\nlife\n++\n\n    \n}\n\n  \n}\n\n\n  \ntakeDamage\n \n(\notherPlayer\n)\n \n{\n\n    \nthis\n.\nlife\n \n-=\n \notherPlayer\n.\ndamage\n\n  \n}\n\n\n}\n\n\n\n\n\n\nHaving defined the \nPlayer\n class, you'd instantiate it rather than using plain objects in the \nStateHandler#addPlayer\n method:\n\n\n// StateHandler.ts\n\n\n// ...\n\n  \naddPlayer\n \n(\nclient\n)\n \n{\n\n    \nthis\n.\nplayers\n[\n \nclient\n.\nid\n \n]\n \n=\n \nnew\n \nPlayer\n();\n\n  \n}\n\n\n// ...", 
            "title": "State handling"
        }, 
        {
            "location": "/api-room-state/#plain-object-state", 
            "text": "The simplest way to deal with the room state is using a plain JavaScript object.  class   ChatRoom   extends   Room   { \n   constructor ( options )   { \n     super ( options ) \n\n     // broadcast patched state every 1 second \n     this . setPatchRate (   1000   ) \n\n     // use a plain object state, holding the room  messages . \n     this . setState ({ \n       messages :   [] \n     }) \n   } \n\n   onMessage   ( client ,   data )   { \n     this . state . messages . push ( data . message ) \n   }  }", 
            "title": "Plain Object State"
        }, 
        {
            "location": "/api-room-state/#state-handler-class", 
            "text": "Even though you can use plain objects to define the state directly in the room handler, the recommended way is to define your own data structures for it, and methods to manipulate the state inside these data structures.  You can use the  @nosync  decorator to define data that won't be synched with the clients (non-enumerable).  import   {   nosync ,   EntityMap   }   from   colyseus ;  export   class   StateHandler   { \n   players :  any   =   {}; \n\n   @nosync   mapBuilder   =    new   MapBuilder (); \n\n   constructor   ()   { \n     this . players   =   {}; \n     this . map   =   this . mapBuilder . build (); \n   } \n\n   restart   ()   { \n     this . map   =   this . mapBuilder . build (); \n   } \n\n   addPlayer   ( client )   { \n     this . players [   client . id   ]   =   {}; \n   } \n\n   removePlayer   ( client )   { \n     delete   this . players [   client . id   ]; \n   }  }   On this example, the  StateHandler  creates a  MapBuilder  instance (that won't be visible in the client-side), which would be responsible for creating the map data. It exposes some methods to be called from the parent  Room  instance, such as  addPlayer  and  restart .  To use this  StateHandler  class in a  Room  instance it would look like this:  import   {   Room   }   from   colyseus  import   {   StateHandler   }   from   ./StateHandler ;  export   class   MapRoom   extends   Room StateHandler   { \n   onInit   ( options )   { \n\n     // sync state every 50ms \n     this . setPatchRate (   1000   /   20   ); \n\n     // initialize StateHandler \n     this . setState (   new   StateHandler ()   ); \n\n     // reset the state every 3 minutes \n     setInterval (()   =   this . state . restart (),   1000   *   60   *   3 ); \n   } \n\n   onJoin   ( client )   { \n     // add player instance to room state \n     this . state . addPlayer ( client ); \n   } \n\n   onLeave   ( client )   { \n     // add player instance to room state \n     this . state . removePlayer ( client ); \n   }  }   You can go on and define more data structures for any kind of object you need. Let's define the  Player  now.  export   class   Player   { \n   life :  number   =   50 ; \n   maxLife :  number   =   50 ; \n   damage :  number   =   9 ; \n\n   constructor   ()   { \n     // recovers a life a little every 2 seconds \n     setInterval (()   =   this . recoverLife (),   2000 ); \n   } \n\n   recoverLife   ()   { \n     if   ( this . life     this . maxLife )   { \n       this . life ++ \n     } \n   } \n\n   takeDamage   ( otherPlayer )   { \n     this . life   -=   otherPlayer . damage \n   }  }   Having defined the  Player  class, you'd instantiate it rather than using plain objects in the  StateHandler#addPlayer  method:  // StateHandler.ts  // ... \n   addPlayer   ( client )   { \n     this . players [   client . id   ]   =   new   Player (); \n   }  // ...", 
            "title": "State Handler Class"
        }, 
        {
            "location": "/api-authentication/", 
            "text": "You may implement the \nverifyClient(client, options)\n method validate the authenticity of your clients. \n\n\nWhen requesting to join a room, that's the order of methods which will be called in your room handler:\n\n\n\n\nrequestJoin\n - should check if a room is available for new clients\n\n\nverifyClient (client, options)\n - should validate the client based on the options provided (i.e. auth token)\n\n\nonJoin (client, options)\n - should initialize the newly connected client into your room's state.\n\n\n\n\nFrom the client-side, you'd call the \njoin\n method with a token from some authentication service (i. e. Facebook):\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nclient\n.\njoin\n(\nworld\n,\n \n{\n\n  \naccessToken\n:\n \nyourFacebookAccessToken\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nclient\n.\nJoin\n(\nworld\n,\n \nnew\n \n{\n\n  \naccessToken\n \n=\n \nyourFacebookAccessToken\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n    \n                \n\n                    \n\n\nThe \nverifyClient\n method in your room handler should return \ntrue\n only if the access token is valid.\n\n\nSynchronous usage\n\n\nYou can immediatelly return a \nboolean\n value.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nverifyClient\n \n(\nclient\n,\n \noptions\n)\n:\n \nboolean\n \n{\n\n    \nreturn\n \n(\noptions\n.\npassword\n \n===\n \nsecret\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAsynchronous usage\n\n\nYou can return a \nPromise\n, and perform some asynchronous task to validate the client.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nverifyClient\n \n(\nclient\n,\n \noptions\n)\n:\n \nPromise\n \n{\n\n    \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n      \nvalidateToken\n(\noptions\n.\naccessToken\n,\n \n(\nerr\n,\n \nsuccess\n)\n \n=\n \n{\n\n        \nif\n \n(\n!\nerr\n)\n \n{\n \n          \nresolve\n();\n\n        \n}\n \nelse\n \n{\n\n          \nreject\n(\nerr\n);\n\n        \n}\n\n      \n});\n\n    \n});\n\n  \n}\n\n\n}\n\n\n\n\n\n\nAlternatively, you can use \nasync\n / \nawait\n, which will return a \nPromise\n under the hood.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n  \nasync\n \nverifyClient\n \n(\nclient\n,\n \noptions\n)\n \n{\n\n    \nconst\n \nuserData\n \n=\n \nawait\n \nvalidateToken\n(\noptions\n.\naccessToken\n);\n\n    \nreturn\n \n(\nuserData\n)\n \n?\n \ntrue\n \n:\n \nfalse\n;\n\n  \n}\n\n\n}", 
            "title": "Authentication"
        }, 
        {
            "location": "/api-authentication/#synchronous-usage", 
            "text": "You can immediatelly return a  boolean  value.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   verifyClient   ( client ,   options ) :   boolean   { \n     return   ( options . password   ===   secret ); \n   }  }", 
            "title": "Synchronous usage"
        }, 
        {
            "location": "/api-authentication/#asynchronous-usage", 
            "text": "You can return a  Promise , and perform some asynchronous task to validate the client.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   verifyClient   ( client ,   options ) :   Promise   { \n     return   new   Promise (( resolve ,   reject )   =   { \n       validateToken ( options . accessToken ,   ( err ,   success )   =   { \n         if   ( ! err )   {  \n           resolve (); \n         }   else   { \n           reject ( err ); \n         } \n       }); \n     }); \n   }  }   Alternatively, you can use  async  /  await , which will return a  Promise  under the hood.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n   async   verifyClient   ( client ,   options )   { \n     const   userData   =   await   validateToken ( options . accessToken ); \n     return   ( userData )   ?   true   :   false ; \n   }  }", 
            "title": "Asynchronous usage"
        }, 
        {
            "location": "/api-graceful-shutdown/", 
            "text": "Graceful Shutdown\n\n\nColyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself:\n\n\n\n\nDisconnect all connected clients asynchronously (\nRoom#onLeave\n)\n\n\nDispose all spawned rooms asynchronously (\nRoom#onDispose\n)\n\n\nPerform optional asynchronous callback before shutting down the process (\nServer#onShutdown\n / \nClusterServer#onShutdown\n)\n\n\n\n\nIf you're performing async tasks on \nonLeave\n / \nonDispose\n, you should return a \nPromise\n, and resolve it when the task is ready. The same applies to \nonShutdown(callback)\n.\n\n\nReturning a \nPromise\n\n\nBy returning a \nPromise\n, the server will wait for them to be completed before killing the worker process.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonLeave\n \n(\nclient\n)\n \n{\n\n        \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n            \ndoDatabaseOperation\n((\nerr\n,\n \ndata\n)\n \n=\n \n{\n\n                \nif\n \n(\nerr\n)\n \n{\n\n                    \nreject\n(\nerr\n);\n\n                \n}\n \nelse\n \n{\n\n                    \nresolve\n(\ndata\n);\n\n                \n}\n\n            \n});\n\n        \n});\n\n    \n}\n\n\n    \nonDispose\n \n()\n \n{\n\n        \nreturn\n \nnew\n \nPromise\n((\nresolve\n,\n \nreject\n)\n \n=\n \n{\n\n            \ndoDatabaseOperation\n((\nerr\n,\n \ndata\n)\n \n=\n \n{\n\n                \nif\n \n(\nerr\n)\n \n{\n\n                    \nreject\n(\nerr\n);\n\n                \n}\n \nelse\n \n{\n\n                    \nresolve\n(\ndata\n);\n\n                \n}\n\n            \n});\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nUsing \nasync\n\n\nThe \nasync\n keyword will makes your function return a \nPromise\n under the hood. \nRead more about Async / Await\n.\n\n\nimport\n \n{\n \nRoom\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nasync\n \nonLeave\n \n(\nclient\n)\n \n{\n\n        \nawait\n \ndoDatabaseOperation\n(\nclient\n);\n\n    \n}\n\n\n    \nasync\n \nonDispose\n \n()\n \n{\n\n        \nawait\n \nremoveRoomFromDatabase\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nProcess shutdown callback\n\n\nYou can also listen for process shutdown by setting a \nonShutdown\n callback.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nServer\n\n        \n\n    \n        \n\n            \nCluster Server\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nimport\n \n{\n \nServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nlet\n \nserver\n \n=\n \nnew\n \nServer\n();\n\n\n\nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n    \nconsole\n.\nlog\n(\nmaster process is being shut down!\n);\n\n\n});\n\n\n\n\n        \n\n    \n        \n\n            \nimport\n \n*\n \nas\n \ncluster\n \nfrom\n \ncluster\n;\n\n\nimport\n \n{\n \nClusterServer\n \n}\n \nfrom\n \ncolyseus\n;\n\n\n\nlet\n \nserver\n \n=\n \nnew\n \nClusterServer\n();\n\n\n\nif\n \n(\ncluster\n.\nisMaster\n)\n \n{\n\n    \nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n        \nconsole\n.\nlog\n(\nmaster process is being shut down!\n);\n\n    \n});\n\n\n\n}\n \nelse\n \n{\n\n    \nserver\n.\nonShutdown\n(\nfunction\n \n()\n \n{\n\n        \nconsole\n.\nlog\n(\nworker process is being shut down!\n);\n\n    \n});\n\n\n}", 
            "title": "Graceful shutdown"
        }, 
        {
            "location": "/api-graceful-shutdown/#graceful-shutdown", 
            "text": "Colyseus provides graceful shutting down mechanism by default. These actions will be performed before the process kill itself:   Disconnect all connected clients asynchronously ( Room#onLeave )  Dispose all spawned rooms asynchronously ( Room#onDispose )  Perform optional asynchronous callback before shutting down the process ( Server#onShutdown  /  ClusterServer#onShutdown )   If you're performing async tasks on  onLeave  /  onDispose , you should return a  Promise , and resolve it when the task is ready. The same applies to  onShutdown(callback) .", 
            "title": "Graceful Shutdown"
        }, 
        {
            "location": "/api-graceful-shutdown/#returning-a-promise", 
            "text": "By returning a  Promise , the server will wait for them to be completed before killing the worker process.  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n     onLeave   ( client )   { \n         return   new   Promise (( resolve ,   reject )   =   { \n             doDatabaseOperation (( err ,   data )   =   { \n                 if   ( err )   { \n                     reject ( err ); \n                 }   else   { \n                     resolve ( data ); \n                 } \n             }); \n         }); \n     } \n\n     onDispose   ()   { \n         return   new   Promise (( resolve ,   reject )   =   { \n             doDatabaseOperation (( err ,   data )   =   { \n                 if   ( err )   { \n                     reject ( err ); \n                 }   else   { \n                     resolve ( data ); \n                 } \n             }); \n         }); \n     }  }", 
            "title": "Returning a Promise"
        }, 
        {
            "location": "/api-graceful-shutdown/#using-async", 
            "text": "The  async  keyword will makes your function return a  Promise  under the hood.  Read more about Async / Await .  import   {   Room   }   from   colyseus ;  class   MyRoom   extends   Room   { \n     async   onLeave   ( client )   { \n         await   doDatabaseOperation ( client ); \n     } \n\n     async   onDispose   ()   { \n         await   removeRoomFromDatabase (); \n     }  }", 
            "title": "Using async"
        }, 
        {
            "location": "/api-graceful-shutdown/#process-shutdown-callback", 
            "text": "You can also listen for process shutdown by setting a  onShutdown  callback.  \n                 \n                    \n         \n            \n         \n             Server \n         \n    \n         \n             Cluster Server \n         \n    \n         \n    \n         \n            \n         \n             import   {   Server   }   from   colyseus ;  let   server   =   new   Server ();  server . onShutdown ( function   ()   { \n     console . log ( master process is being shut down! );  });  \n\n         \n    \n         \n             import   *   as   cluster   from   cluster ;  import   {   ClusterServer   }   from   colyseus ;  let   server   =   new   ClusterServer ();  if   ( cluster . isMaster )   { \n     server . onShutdown ( function   ()   { \n         console . log ( master process is being shut down! ); \n     });  }   else   { \n     server . onShutdown ( function   ()   { \n         console . log ( worker process is being shut down! ); \n     });  }", 
            "title": "Process shutdown callback"
        }, 
        {
            "location": "/api-debugging/", 
            "text": "Debug messages\n\n\nInspector (\n--inspect\n flag)\n\n\n\n\nDebug messages\n\n\nThe server provides some debug messages that you can enable individually per category, by setting the \nDEBUG\n environment variable.\n\n\nTo enable all logs, you can run your server using:\n\n\nDEBUG=colyseus:* node server.js\n\n\n\n\n\nSee below all available debug categories with sample outputs.\n\n\ncolyseus:patch\n\n\nLogs the number of bytes and interval between patches broadcasted to all clients.\n\n\ncolyseus:patch \nchat\n (roomId: \nryWiL5rLTZ\n) is sending 28 bytes: +57ms\n\n\n\n\n\ncolyseus:patch:data\n\n\nDisplays a human-readable version of the data broadcasted to all clients.\n\n\ncolyseus:patch:data [ { op: \nreplace\n, path: \n/players/BygiLqrLpZ/x\n, value: 5 } ] +56ms\n\n\n\n\n\ncolyseus:cluster\n\n\nLogs when worker processes are spawned and re-spawned. \n\n\ncolyseus:cluster master spawned with pid 77216 +0ms\ncolyseus:cluster matchmaking spawned with pid 77217 +8ms\ncolyseus:cluster fork spawned with pid 77218 +7ms\ncolyseus:cluster fork spawned with pid 77219 +3ms\ncolyseus:cluster fork spawned with pid 77220 +3ms\ncolyseus:cluster fork spawned with pid 77221 +17ms\n\n\n\n\n\ncolyseus:matchmaking\n\n\nLogs the messages sent back and forth from master node to worker processes. You'll see them only if using \nClusterServer\n.\n\n\ncolyseus:matchmaking requesting CREATE_ROOM +54s\ncolyseus:matchmaking spawning \nchat\n on worker 77218 +52s\ncolyseus:matchmaking disposing \nchat\n on worker 77218 +2s\n\n\n\n\n\nInspector\n\n\nTo be able to use the \nbuilt-in inspector from Node.js\n\nyou'll need to use the \nServer\n class, which doesn't use inter-process communication. \n\n\nFor production, \nClusterServer\n is recommended, though.", 
            "title": "Debugging"
        }, 
        {
            "location": "/api-debugging/#debug-messages", 
            "text": "The server provides some debug messages that you can enable individually per category, by setting the  DEBUG  environment variable.  To enable all logs, you can run your server using:  DEBUG=colyseus:* node server.js  See below all available debug categories with sample outputs.", 
            "title": "Debug messages"
        }, 
        {
            "location": "/api-debugging/#colyseuspatch", 
            "text": "Logs the number of bytes and interval between patches broadcasted to all clients.  colyseus:patch  chat  (roomId:  ryWiL5rLTZ ) is sending 28 bytes: +57ms", 
            "title": "colyseus:patch"
        }, 
        {
            "location": "/api-debugging/#colyseuspatchdata", 
            "text": "Displays a human-readable version of the data broadcasted to all clients.  colyseus:patch:data [ { op:  replace , path:  /players/BygiLqrLpZ/x , value: 5 } ] +56ms", 
            "title": "colyseus:patch:data"
        }, 
        {
            "location": "/api-debugging/#colyseuscluster", 
            "text": "Logs when worker processes are spawned and re-spawned.   colyseus:cluster master spawned with pid 77216 +0ms\ncolyseus:cluster matchmaking spawned with pid 77217 +8ms\ncolyseus:cluster fork spawned with pid 77218 +7ms\ncolyseus:cluster fork spawned with pid 77219 +3ms\ncolyseus:cluster fork spawned with pid 77220 +3ms\ncolyseus:cluster fork spawned with pid 77221 +17ms", 
            "title": "colyseus:cluster"
        }, 
        {
            "location": "/api-debugging/#colyseusmatchmaking", 
            "text": "Logs the messages sent back and forth from master node to worker processes. You'll see them only if using  ClusterServer .  colyseus:matchmaking requesting CREATE_ROOM +54s\ncolyseus:matchmaking spawning  chat  on worker 77218 +52s\ncolyseus:matchmaking disposing  chat  on worker 77218 +2s", 
            "title": "colyseus:matchmaking"
        }, 
        {
            "location": "/api-debugging/#inspector", 
            "text": "To be able to use the  built-in inspector from Node.js \nyou'll need to use the  Server  class, which doesn't use inter-process communication.   For production,  ClusterServer  is recommended, though.", 
            "title": "Inspector"
        }, 
        {
            "location": "/client-overview/", 
            "text": "Overview", 
            "title": "Overview"
        }, 
        {
            "location": "/client-overview/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/client-state-synchronization/", 
            "text": "Whenever the \nstate mutates\n in the server-side, you can listen to particular variable changes in the client-side.\n\n\nThe \nRoom\n instance in the client-side uses \ndelta-listener\n to allow you to trigger callbacks for particular mutations.\n\n\nExample\n\n\nLet's say you have a list of entities and its positions in your server-side:\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonInit\n \n()\n \n{\n\n        \nthis\n.\nsetState\n({\n\n            \nentities\n:\n \n{\n\n                \nf98h3f\n:\n \n{\n \nx\n:\n \n0\n,\n \ny\n:\n \n0\n,\n \nhp\n:\n \n10\n \n},\n\n                \n24jgd3\n:\n \n{\n \nx\n:\n \n100\n,\n \ny\n:\n \n0\n,\n \nhp\n:\n \n6\n \n}\n\n            \n}\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn the client-side, you want to listen for mutations in the attributes of these entities. Before being able to catch them, we need to mutate them. The mutation can occur during your simulation interval, or by actions taken by connected clients (during \nonMessage\n in the server-side).\n\n\nclass\n \nMyRoom\n \nextends\n \nRoom\n \n{\n\n    \nonInit\n \n()\n \n{\n\n        \n// this.setState(...) see above\n\n        \nthis\n.\nsetSimulationInterval\n(()\n \n=\n \nthis\n.\nupdate\n());\n\n    \n}\n\n\n    \nupdate\n \n()\n \n{\n\n        \nfor\n \n(\nlet\n \nentityId\n \nin\n \nthis\n.\nstate\n.\nentities\n)\n \n{\n\n            \n// simple and naive gravity\n\n            \nthis\n.\nstate\n.\nentities\n[\nentityId\n].\ny\n \n+=\n \n1\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow that we have the mutations in place, we can listen to them in the client-side. The callback will be called for each attribute, of each entity.\n\n\n\n                \n\n                    \n        \n\n            \n        \n\n            \nJavaScript\n\n        \n\n    \n        \n\n            \nC#\n\n        \n\n    \n        \n\n    \n        \n\n            \n        \n\n            \nroom\n.\nlisten\n(\nentities/:id/:attribute\n,\n \n(\nchange\n)\n \n=\n \n{\n\n    \nconsole\n.\nlog\n(\nchange\n.\noperation\n);\n \n// =\n \nreplace\n (can be \nadd\n, \nremove\n or \nreplace\n)\n\n    \nconsole\n.\nlog\n(\nchange\n.\npath\n[\nid\n]);\n \n// =\n \nf98h3f\n\n    \nconsole\n.\nlog\n(\nchange\n.\npath\n[\nattribute\n]);\n \n// =\n \ny\n\n    \nconsole\n.\nlog\n(\nchange\n.\nvalue\n);\n \n// =\n 1\n\n\n})\n\n\n\n\n        \n\n    \n        \n\n            \nroom\n.\nListen\n(\nentities/:id/:attribute\n,\n \nOnAttributeChange\n);\n\n\n\nvoid\n \nOnAttributeChange\n \n(\nDataChange\n \nchange\n)\n\n\n{\n\n    \nDebug\n.\nLog\n \n(\nOnAttributeChange\n);\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\noperation\n);\n \n// =\n \nreplace\n (can be \nadd\n, \nremove\n or \nreplace\n)\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nid\n]);\n \n// =\n \nf98h3f\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\npath\n[\nattribute\n]);\n \n// =\n \ny\n\n    \nDebug\n.\nLog\n \n(\nchange\n.\nvalue\n);\n \n// =\n 1\n\n\n})", 
            "title": "State synchronization"
        }, 
        {
            "location": "/deployment/", 
            "text": "Deploying on Heroku\n\n\nDeploying on Zeit Now\n\n\nDeploying on Nginx (recommended)\n\n\n\n\nHeroku\n\n\nYou can deploy the \ncolyseus-examples\n project on Heroku by gitting this button: \n\n\n\n\nNote:\n You can't use the \nClusterServer\n under Heroku's free tier. Only \nServer\n works on free tier, which doesn't use multiple processes.\n\n\nZeit Now\n\n\nYou can deploy the \ncolyseus-examples\n project on Zeit Now by gitting this button: \n\n\n\n\nNote:\n You can't use the \nClusterServer\n under Zeit Now's free tier. Only \nServer\n works on free tier, which doesn't use multiple processes.\n\n\nNginx (recommended)\n\n\nIt's recommended to use \nforever\n and \nnginx\n in your production environment.\n\n\nForever\n\n\nInstall \nforever\n in your environment.\n\n\nnpm install -g forever\n\n\n\n\n\nThen start your game server using it:\n\n\nforever your-server.js\n\n\n\n\n\nNginx configuration\n\n\nserver {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \nupgrade\n;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}\n\n\n\n\n\nNginx configuration with SSL\n\n\nIt's recommended to acquire your certificate from \nLetsEncrypt\n.\n\n\nserver {\n    listen 80;\n    listen 443 ssl;\n    server_name yourdomain.com;\n\n    ssl_certificate /path/to/your/cert.crt;\n    ssl_certificate_key /path/to/your/cert.key;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \nupgrade\n;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Deployment"
        }, 
        {
            "location": "/deployment/#heroku", 
            "text": "You can deploy the  colyseus-examples  project on Heroku by gitting this button:    Note:  You can't use the  ClusterServer  under Heroku's free tier. Only  Server  works on free tier, which doesn't use multiple processes.", 
            "title": "Heroku"
        }, 
        {
            "location": "/deployment/#zeit-now", 
            "text": "You can deploy the  colyseus-examples  project on Zeit Now by gitting this button:    Note:  You can't use the  ClusterServer  under Zeit Now's free tier. Only  Server  works on free tier, which doesn't use multiple processes.", 
            "title": "Zeit Now"
        }, 
        {
            "location": "/deployment/#nginx-recommended", 
            "text": "It's recommended to use  forever  and  nginx  in your production environment.", 
            "title": "Nginx (recommended)"
        }, 
        {
            "location": "/deployment/#forever", 
            "text": "Install  forever  in your environment.  npm install -g forever  Then start your game server using it:  forever your-server.js", 
            "title": "Forever"
        }, 
        {
            "location": "/deployment/#nginx-configuration", 
            "text": "server {\n    listen 80;\n    server_name yourdomain.com;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection  upgrade ;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Nginx configuration"
        }, 
        {
            "location": "/deployment/#nginx-configuration-with-ssl", 
            "text": "It's recommended to acquire your certificate from  LetsEncrypt .  server {\n    listen 80;\n    listen 443 ssl;\n    server_name yourdomain.com;\n\n    ssl_certificate /path/to/your/cert.crt;\n    ssl_certificate_key /path/to/your/cert.key;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection  upgrade ;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n        proxy_read_timeout 86400s;\n        proxy_send_timeout 86400s;\n    }\n}", 
            "title": "Nginx configuration with SSL"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\nHow would I broadcast data from one client to others?\n\n\nYou usually don't do that. By using an authoritative game server, the clients generally send \nactions\n to the server, and the server \nmutates\n the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval.\n\n\nDo I need client-prediction in my game? Does Colyseus help me with this?\n\n\nColyseus does not provide any client-prediction solution out of the box. Games such as \nwilds.io\n and \ncrashracing.com\n do not use any form of client-prediction. \nlerp\ning user coordinates usually gives reasonable results.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#how-would-i-broadcast-data-from-one-client-to-others", 
            "text": "You usually don't do that. By using an authoritative game server, the clients generally send  actions  to the server, and the server  mutates  the state of the game session. After having the mutation, all clients will receive the latest state from the server in the next patch interval.", 
            "title": "How would I broadcast data from one client to others?"
        }, 
        {
            "location": "/faq/#do-i-need-client-prediction-in-my-game-does-colyseus-help-me-with-this", 
            "text": "Colyseus does not provide any client-prediction solution out of the box. Games such as  wilds.io  and  crashracing.com  do not use any form of client-prediction.  lerp ing user coordinates usually gives reasonable results.", 
            "title": "Do I need client-prediction in my game? Does Colyseus help me with this?"
        }, 
        {
            "location": "/architecture/", 
            "text": "Architecture\n\n\nState sync / Binary patches\n\n\nWhen connected to a Room, all the clients should have access to the full state available from the server. Here's how it works:\n\n\n\n\nUpon the first connection, the client receives the latest encoded room state (\nmsgpack format\n).\n\n\nAt the \npatchRate\n interval (default: 50ms), the server will encode the whole room state again. If it differs from the latest encoded state, the delta (\nfossil's delta\n) between the latest state and the new state is calculated and sent to all connected clients.\n\n\nWhen the client receives the delta, it is applied against the latest encoded state (the result of the last applied patch), and then decoded.", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#architecture", 
            "text": "", 
            "title": "Architecture"
        }, 
        {
            "location": "/architecture/#state-sync-binary-patches", 
            "text": "When connected to a Room, all the clients should have access to the full state available from the server. Here's how it works:   Upon the first connection, the client receives the latest encoded room state ( msgpack format ).  At the  patchRate  interval (default: 50ms), the server will encode the whole room state again. If it differs from the latest encoded state, the delta ( fossil's delta ) between the latest state and the new state is calculated and sent to all connected clients.  When the client receives the delta, it is applied against the latest encoded state (the result of the last applied patch), and then decoded.", 
            "title": "State sync / Binary patches"
        }, 
        {
            "location": "/roadmap/", 
            "text": "Overview:\n\n\n\n\n~~Support vertical scalability (\n#43\n)~~ - \u2714\n\n\n~~Standardize how to authenticate users in a secure way. (\n#49\n, suggested by \n@darkyen\n)~~ - \u2714\n\n\nSupport for splitting and filtering views (\n#59\n, suggested by \n@darkyen\n and the whole \ngitter channel\n!)\n\n\nSupport serialization methods other than Fossil's Delta algorithm. (\n#58\n, suggested by \n@derwish-pro\n)\n\n\nPM2 support (\n#56\n)\n\n\nSupport horizontal scalability. (\n#57\n)\n\n\nSupport transport layers other than WebSocket. (\n#48\n, suggested by \n@darkyen\n)\n\n\n\n\nIn order to achieve these goals, it would be great to split Colyseus's internal parts as composable modules. Specially match-making, which is the most complex feature to deal with by having multiple servers/processes running.", 
            "title": "Roadmap"
        }, 
        {
            "location": "/roadmap/#overview", 
            "text": "~~Support vertical scalability ( #43 )~~ - \u2714  ~~Standardize how to authenticate users in a secure way. ( #49 , suggested by  @darkyen )~~ - \u2714  Support for splitting and filtering views ( #59 , suggested by  @darkyen  and the whole  gitter channel !)  Support serialization methods other than Fossil's Delta algorithm. ( #58 , suggested by  @derwish-pro )  PM2 support ( #56 )  Support horizontal scalability. ( #57 )  Support transport layers other than WebSocket. ( #48 , suggested by  @darkyen )   In order to achieve these goals, it would be great to split Colyseus's internal parts as composable modules. Specially match-making, which is the most complex feature to deal with by having multiple servers/processes running.", 
            "title": "Overview:"
        }
    ]
}